---
subtitle: 'Gametocyte Development in <i>Plasmodium berghei</i>'
title: |
  ![](../GCSKO_logo.jpg){width=300px}  
  Co-expression Analysis
author: "[Andrew Russell](https://ajcrussell.wixsite.com/mysite/about)"
institute: Wellcome Sanger Institute
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_notebook:
    theme: cosmo
    toc: yes
    toc_depth: 3
    #toc_float: yes
    df_print: paged
---
***
# 1. Introduction and Aims {.tabset}

We want to inspect how genes are coexpressed across the entire lifecycle of the parasite. 

# 2. Read in the data  {.tabset}

## Load/Install the Required Packages

```{r load packages, echo = FALSE}
## CRAN packages

## Seurat is needed for most of this script
if(require("Seurat", quietly = TRUE)){
    print("Seurat is loaded correctly")
} else {
    print("trying to install Seurat")
    install.packages("Seurat")
    if(require(Seurat)){
        print("Seurat installed and loaded")
    } else {
        stop("could not install Seurat")
    }
}

## psych is needed for poran et al. script
if(require("psych", quietly = TRUE)){
    print("psych is loaded correctly")
} else {
    print("trying to install psych")
    install.packages("psych")
    if(require(psych)){
        print("psych installed and loaded")
    } else {
        stop("could not install psych")
    }
}

## doParallel is needed for poran et al. script
if(require("doParallel", quietly = TRUE)){
    print("doParallel is loaded correctly")
} else {
    print("trying to install doParallel")
    install.packages("doParallel")
    if(require(doParallel)){
        print("doParallel installed and loaded")
    } else {
        stop("could not install doParallel")
    }
}


## non-CRAN packages

```

## functions

```{r}
coX<-function(genePair,exprMat,thresh=0,corMethod = "spearman"){
	require("psych",quietly=F)
	exprMat<-as.matrix(exprMat)
	geneA<-as.character(genePair[1])
	geneB<-as.character(genePair[2])
	
	# if genes not above threshold or expressed in all cells, function returns a NULL row that won't show up in a data frame being generated when applied
	nullreturn<-data.frame(geneA=character(),geneB=character(),phi=numeric(),OddsRatio=numeric(),p.value=numeric(),cor=numeric(),BonInAon=numeric(),BonInAoff=numeric(),meanDGE=numeric())
	if(mean(exprMat[geneA,]>0)<=thresh | mean(exprMat[geneA,]>0)==1){return(nullreturn)}
	if(mean(exprMat[geneB,]>0)<=thresh | mean(exprMat[geneB,]>0)==1){return(nullreturn)}
	
	#print(paste(geneA,geneB,"by=",unique(exprMat["by",])))
				
	conTable<-table(exprMat[geneA,]!=0,exprMat[geneB,]!=0) #create contingency table
	#print(conTable)
	ft<-fisher.test(conTable) # calculate fishers exact test
	coreff<-round(cor(exprMat[geneA,],exprMat[geneB,],method=corMethod),3) #calculate correlation coefficient
	BonInAon<-round(conTable[2,2]/sum(conTable[2,]),3) #percentage in ON
	BonInAoff<-round(conTable[1,2]/sum(conTable[1,]),3) #percentage in OFF
	meanDGE<-round(log(mean(exprMat[geneB,exprMat[geneA,]>0])/mean(exprMat[geneB,exprMat[geneA,]==0]),2),3) #mean difference in gene expression
	
	# return GeneA GeneB Phi OddsRatio p.value and correlation coefficient
	return(data.frame(geneA=geneA,geneB=geneB,phi=round(phi(conTable),3),OddsRatio=round(as.numeric(ft$estimate),3),p.value=ft$p.value,cor=coreff,BonInAon=BonInAon,BonInAoff=BonInAoff,meanDGE=meanDGE))
}	


multicoX<-function(geneListA, geneListB=NULL, exprMat, thresh=0, by=NULL, p.adjust="fdr", parallel=FALSE, cores=29, corMethod ="spearman"){
	require(plyr)
  if(is.null(geneListB)){genePairs<-data.frame(t(combn(geneListA,2)))} # if no geneB do all combinations of GeneA
	else{ #if geneB is set 
		geneListB<-geneListB[!(geneListB %in% geneListA)] # Eliminate duplicate genes
		if(geneListB[1]=="all"){genePairs<-expand.grid(geneListA,rownames(exprMat))} #if geneB is "all", compare all the genes
		else{genePairs<-expand.grid(geneListA,geneListB)}
	}
	genePairs %>% dplyr::mutate_if(is.factor, as.character) -> genePairs # return factors columns to character
	genePairs<-genePairs[genePairs[,1]!=genePairs[,2],] # remove self-correlations
	genePairs=as.list(data.frame(t(genePairs)))
	
	if(parallel){
		registerDoParallel(cores=20) # or registerDoParallel() if you want to use all the cores
	}
	if(is.null(by)){
		cx<-plyr::ldply(.data = genePairs,.fun = coX,exprMat=exprMat,thresh=thresh,corMethod,.id=NULL,.parallel = parallel)
		cx$p.value<-p.adjust(cx$p.value,method=p.adjust)		
	}else{
		by<-factor(by)
		funx<-function(fd,genePairs,thresh,corMethod = "spearman"){  # then for each separate transposed expression matrix
			df<-t(fd)  # retranspose
			# if we can remove these first they dont need to run
			cxx<-plyr::ldply(.data = genePairs,.fun = coX,exprMat=df,thresh=thresh,corMethod,.id=NULL,.parallel = parallel)
			cxx$p.value<-p.adjust(cxx$p.value,method=p.adjust) #adjust p.value
			return(cxx) # return to ddply
		}
		taMrpxe<-cbind(by,t(as.matrix(exprMat)))
		rownames(taMrpxe)<-colnames(exprMat)
		cx<-ddply(data.frame(taMrpxe),.(by),.fun=funx, genePairs,thresh=thresh,corMethod)
	}
	return(cx[order(cx$phi),])
}


getInfo<-function(genes, cols=c("geneID","name","description"),file=NULL,sep="\t"){  # need failure mode for genes not in the list
	if(is.null(file)){
		missing<-genes[!(genes %in% GeneInfo$geneID)]
	
		if(cols[1]=="all"){return(GeneInfo[sapply(genes,grep,GeneInfo$geneID),])}
		else{return(GeneInfo[sapply(genes,grep,GeneInfo$geneID),cols])}
	}
	else{
		tab<-read.csv(file,sep="\t",stringsAsFactors =FALSE)
		if(cols[1]=="all"){return(tab[sapply(genes,grep,GeneInfo$geneID),])}
		else{return(tab[sapply(genes,grep,GeneInfo$geneID),cols])}
	}
}
```


## load data

tenx.mutant.integrated is needed from the merge script

```{r}
## load dataset
tenx.mutant.integrated <- readRDS("../data_to_export/tenx.mutant.integrated.RDS")
```

# 3. Correlation Analysis of AP2G {.tabset}

## all cells

We can look to see if there are any genes with correlated highly with AP2G expression
```{r}
##ref: https://github.com/satijalab/seurat/issues/519 
## extract data from seurat
matrix <- tenx.mutant.integrated@assays$RNA@data

## make into a matrix
matrix_mod<-as.matrix(matrix)

## extract gene of interest
gene<-as.numeric(matrix_mod["PBANKA-1437500",])

## perform correlations
correlations<-apply(matrix_mod,1,function(x){cor(gene,x)})

## extract the top 100 correlated genes
top_hundred <- tail(na.omit(correlations[order(correlations)]), 200)

## create a list of our mutant gene IDs
list_of_mutant_genes <- c("PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-1144800", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")

## find out if any of our genes of interest are coexpressed with AP2G
top_hundred[which(names(top_hundred) %in% list_of_mutant_genes)]
```

This is mutant 29, we can also visualise this in a dot plot

```{r}
df_plot <- data.frame(t(data.frame(matrix_mod[c("PBANKA-1447900", "PBANKA-1437500"), ])))

ggplot(df_plot, aes(PBANKA.1447900, PBANKA.1437500)) + geom_point()
```

## by cluster

Let's remind ourselves of the clusters:

```{r, fig.height = 4, fig.width = 4}
## Plot
umap_cluster <- DimPlot(tenx.mutant.integrated, label = TRUE, label.size = 8, repel = FALSE, pt.size = 0.5, dims = c(2,1), reduction = "DIM_UMAP") + 
  coord_fixed() +
  theme(legend.position="bottom", 
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()) + 
  guides(colour=guide_legend(nrow = 3, byrow = TRUE, override.aes = list(size=5)))

## print
umap_cluster
```

The most interesting clusters are perhaps 7, 0, 3, 13 - let's repeat this analysis but only inside these clusters to reduce noise

```{r}
##ref: https://github.com/satijalab/seurat/issues/519 
## extract data from seurat
matrix <- tenx.mutant.integrated@assays$RNA@data

## get all cells in cluster 3
cluster_three_cells <- rownames(tenx.mutant.integrated@meta.data[which(tenx.mutant.integrated@meta.data$seurat_clusters == 3), ])

## subset matrix so it only contains cells of interest
matrix <- matrix[ ,which(colnames(matrix) %in% cluster_three_cells)]

## make into a matrix
matrix_mod<-as.matrix(matrix)

## extract gene of interest
gene<-as.numeric(matrix_mod["PBANKA-1437500",])

## perform correlations
correlations<-apply(matrix_mod,1,function(x){cor(gene,x)})

## extract the top 100 correlated genes
top_hundred <- tail(na.omit(correlations[order(correlations)]), 200)

## create a list of our mutant gene IDs
list_of_mutant_genes <- c("PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-1144800", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")

## find out if any of our genes of interest are coexpressed with AP2G
top_hundred[which(names(top_hundred) %in% list_of_mutant_genes)]
```

But it may be that AP2G+ cells actually are split into two.


## Poran et al. method

```{r}
pbDS <- tenx.mutant.integrated

## subset only AP2-G postive cells
pbDS@meta.data$ap2gPos <- pbDS@assays$RNA@data["PBANKA-1437500",]>0

## define hits - for me this will be my genes of interest
hits=c("PBANKA-1437500")#nf54+ap2g alone

## you need to remove any genes that have a row means of 0 
pbDS@assays$RNA@data <- pbDS@assays$RNA@data[-which(rowMeans(pbDS@assays$RNA@data) == 0), ]

## calculate correlations
AP2GbyClusterTreat.coX.spear <- multicoX(geneListA=hits, geneListB="all", exprMat = pbDS@assays$RNA@data, parallel=F,corMeth="spearman")
```

Find mutant genes
```{r}
mutant_cox <- AP2GbyClusterTreat.coX.spear[which(AP2GbyClusterTreat.coX.spear$geneA %in% list_of_mutant_genes | AP2GbyClusterTreat.coX.spear$geneB %in% list_of_mutant_genes), ]


## only select matches that are significant 
mutant_cox<-mutant_cox[mutant_cox$p.value<0.05,] # significant

## cor & phi agree on direction
mutant_cox<-mutant_cox[sign(mutant_cox$phi)==sign(mutant_cox$cor),] 

# significant
mutant_cox<-mutant_cox[mutant_cox$phi>0.3,]

## view
View(mutant_cox)
```



Derived from: https://github.com/KafsackLab/scRNAseq-Malaria/blob/master/Main_figures_code.R 
```{r}
###############   Figure 4E: Co-expression networks in AP2G+nf54 
###Create a seurat object combining both NF54 and AP2Gdd cells (by modifiy "Seurat_setup_code.R")
## subset only postive cells
PfDS@data.info$ap2gPos=PfDS@data["PF3D7_1222600",]>0

## ? subset to remove treatment cells
subset=SubsetData(PfDS, cells.use = rownames(PfDS@data.info[PfDS@data.info$treat!="OFF",]))

## ? subset even more to remove another cells type
subset=SubsetData(subset, cells.use = rownames(subset@data.info[subset@data.info$tp!="GC2",]))

## subset even more to only include clusters of interest
subset=SubsetData(subset, cells.use = rownames(subset@data.info[subset@data.info$cluster %in% 1:11,]))

## rename subset into new object which is input for later
PfDS=subset;rm(subset)

load("DE_EachStrainSeparately.RData") #Generated using "DifferentialExP_ByStrain.R"

## define hits - for me this will be my genes of interest
hits=c("PF3D7_1222600",intersect(deGenesAllClusNF54$geneID,deGenesAllClusAP2G$geneID))#nf54+ap2g alone


## calculate correlations
AP2GbyClusterTreat.coX.spear<-multicoX(geneListA=hits, geneListB="all", exprMat = PfDS@data, by=PfDS@data.info$cluster,parallel=T,corMeth="spearman")


## only select matches that are significant 
AP2GbyClusterTreat.coX.spear<-AP2GbyClusterTreat.coX.spear[AP2GbyClusterTreat.coX.spear$p.value<0.05,] # significant

## cor & phi agree on direction
AP2GbyClusterTreat.coX.spear<-AP2GbyClusterTreat.coX.spear[sign(AP2GbyClusterTreat.coX.spear$phi)==sign(AP2GbyClusterTreat.coX.spear$cor),] 

## only select genes in list of genes (presmably this removes non-polyA genes)
AP2GbyClusterTreat.coX.spear<-AP2GbyClusterTreat.coX.spear[AP2GbyClusterTreat.coX.spear$geneB %in% GeneInfo$geneID,]

## make a new col for cluster ID
AP2GbyClusterTreat.coX.spear$by2=levels(factor(PfDS@data.info$cluster))[AP2GbyClusterTreat.coX.spear$by]

## rename col 
AP2GbyClusterTreat.coX.spear$clus=AP2GbyClusterTreat.coX.spear$by

# significant
AP2GbyClusterTreat.coX.spear<-AP2GbyClusterTreat.coX.spear[AP2GbyClusterTreat.coX.spear$phi>0.3,]

## get the gene name and add
AP2GbyClusterTreat.coX.spear$geneAname=getInfo(AP2GbyClusterTreat.coX.spear$geneA,"name")

## get the gene name and add
AP2GbyClusterTreat.coX.spear$geneBname=getInfo(AP2GbyClusterTreat.coX.spear$geneB,"name")

##
tab=table(AP2GbyClusterTreat.coX.spear$geneBname)

##
tab=tab[tab>5]

##
AP2GbyClusterTreat.coX.spearFilt_forSupTable=AP2GbyClusterTreat.coX.spear[AP2GbyClusterTreat.coX.spear$geneBname %in% names(tab),]

#for supp table
fishTable=data.frame(t(sapply(1:nrow(AP2GbyClusterTreat.coX.spearFilt_forSupTable),function(i){
ct=table(PfDS@data[AP2GbyClusterTreat.coX.spearFilt_forSupTable$geneA[i],PfDS@ident==AP2GbyClusterTreat.coX.spearFilt_forSupTable$by[i]]>0,
         PfDS@data[AP2GbyClusterTreat.coX.spearFilt_forSupTable$geneB[i],PfDS@ident==AP2GbyClusterTreat.coX.spearFilt_forSupTable$by[i]]>0)
ft=fisher.test(ct)
c(as.vector(ct),ft$estimate,ft$conf.int)
})))

## add names to table
names(fishTable)=c("Aoff_Boff","Aoff_Bon","Aon_Boff","Aon_Bon","oddsRatio2","conf1","conf2")

## bind fish table with sup table
AP2GbyClusterTreat.coX.spearFilt_forSupTable=cbind(AP2GbyClusterTreat.coX.spearFilt_forSupTable,fishTable)

#for net
AP2GbyClusterTreat.coX.spearFilt=AP2GbyClusterTreat.coX.spear[AP2GbyClusterTreat.coX.spear$geneBname %in% names(tab),c("clus","geneA","geneB")]
AP2GbyClusterTreat.coX.spearFilt=data.frame(t(apply(AP2GbyClusterTreat.coX.spearFilt[,2:3], 1, sort)),AP2GbyClusterTreat.coX.spearFilt$clus);names(AP2GbyClusterTreat.coX.spearFilt)=c("A","B","clus")
df=plyr::count(unique(AP2GbyClusterTreat.coX.spearFilt), vars = c("A", "B"))   

g=graph.data.frame(df,directed = F)
E(g)$weight=df$freq 
V(g)$Motifs=getInfo(V(g)$name,"ap2gMotifs_3k")
V(g)$altName=getInfo(V(g)$name,"name")

AP2GbyClusterTreat.coX.spear$clus=factor(AP2GbyClusterTreat.coX.spear$clus)

```


