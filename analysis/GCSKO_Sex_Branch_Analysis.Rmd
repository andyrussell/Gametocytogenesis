---
subtitle: 'Gametocyte Development in <i>Plasmodium berghei</i>'
title: |
  ![](../GCSKO_logo.jpg){width=300px}  
  Pseudotime Sexual Branch
author: "[Andrew Russell](https://ajcrussell.wixsite.com/mysite/about)"
institute: Wellcome Sanger Institute
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_notebook:
    theme: cosmo
    toc: yes
    toc_depth: 3
    #toc_float: yes
    df_print: paged
---
***
# 1. Introduction and Aims {.tabset}

We have merged the two datasets together in GCSKO_merge.Rmd. We also subsetted out the pre-sexual-branch and the sexual cells (male and female) and stored them in a Seurat object called tenx.mutant.integrated.sex. Here, we will perform pseudotime analysis on the dataset and build modules of genes that show similar expression across this pseudotime.

# 2. Read in the data  {.tabset}

## Load/Install the Required Packages

```{r load packages, echo = FALSE}
## CRAN packages

## Patchwork is needed to stich plots together using '+'
if(require("patchwork", quietly = TRUE)){
    print("patchwork is loaded correctly")
} else {
    print("trying to install patchwork")
    install.packages("patchwork")
    if(require(patchwork)){
        print("patchwork installed and loaded")
    } else {
        stop("could not install patchwork")
    }
}

## viridis allows different colours to be added to plots
if(require("viridis", quietly = TRUE)){
    print("viridis is loaded correctly")
} else {
    print("trying to install viridis")
    install.packages("viridis")
    if(require(viridis)){
        print("viridis installed and loaded")
    } else {
        stop("could not install viridis")
    }
}

## Seurat is needed for most of this script
if(require("Seurat", quietly = TRUE)){
    print("Seurat is loaded correctly")
} else {
    print("trying to install Seurat")
    install.packages("Seurat")
    if(require(Seurat)){
        print("Seurat installed and loaded")
    } else {
        stop("could not install Seurat")
    }
}

## cowplot is needed for plots in this script
if(require("cowplot")){
    print("cowplot is loaded correctly")
} else {
    print("trying to install cowplot")
    install.packages("cowplot")
    if(require(cowplot)){
        print("cowplot installed and loaded")
    } else {
        stop("could not install cowplot")
    }
}

## gridExtra is needed for grid graphics to plot multiple plots in the same view
if(require("gridExtra")){
    print("gridExtra is loaded correctly")
} else {
    print("trying to install gridExtra")
    install.packages("gridExtra")
    if(require(gridExtra)){
        print("gridExtra installed and loaded")
    } else {
        stop("could not install gridExtra")
    }
}

## grid is needed for grid.arrange function to change size of title
if(require("grid")){
    print("grid is loaded correctly")
} else {
    print("trying to install grid")
    install.packages("grid")
    if(require(grid)){
        print("grid installed and loaded")
    } else {
        stop("could not install grid")
    }
}

##for doing bulk correlation calculations
if(require("Hmisc")){
    print("Hmisc is loaded correctly")
} else {
    print("trying to install Hmisc")
    install.packages("Hmisc")
    if(require(Hmisc)){
        print("Hmisc installed and loaded")
    } else {
        stop("could not install Hmisc")
    }
}

## reshape2 to melt dataframes for plotting:
if(require("reshape2")){
    print("reshape2 is loaded correctly")
} else {
    print("trying to install reshape2")
    install.packages("reshape2")
    if(require(reshape2)){
        print("reshape2 installed and loaded")
    } else {
        stop("could not install reshape2")
    }
}

## to work with data frames:
if(require("dplyr")){
    print("dplyr is loaded correctly")
} else {
    print("trying to install dplyr")
    install.packages("dplyr")
    if(require(dplyr)){
        print("dplyr installed and loaded")
    } else {
        stop("could not install dplyr")
    }
}

## this allows us to use the colorRamp2 function which allows us to plot nice colour gradient pals:
if(require("circlize")){
    print("circlize is loaded correctly")
} else {
    print("trying to install circlize")
    install.packages("circlize")
    if(require(circlize)){
        print("circlize installed and loaded")
    } else {
        stop("could not install circlize")
    }
}

## non-CRAN packages

## monocle3 to calculate pseudotime:
if(require("monocle3")){
    print("monocle3 is loaded correctly")
} else {
    print("Please install monocle3 (https://cole-trapnell-lab.github.io/monocle3/docs/installation/)")
}

## destiny is used for diffusion plots (DiffusionMap function)
if(require("destiny")){
    print("destiny is loaded correctly")
} else {
  print("trying to install destiny")
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install("destiny")
  if(require(destiny)){
        print("destiny installed and loaded")
    } else {
        stop("could not install destiny")
    }
}

#set the seed for both the mixture models and also for the sample function later on:
set.seed(-92497)
```

## load data

```{r}
## load sex only branch cells saved from GCSKO_Sex_Branch_Analysis.Rmd
## Restore the objects
## load sex branch dataset
tenx.mutant.integrated.sex <- readRDS("../data_to_export/tenx.mutant.integrated.sex.RDS")
## load full dataset
#tenx.mutant.integrated <- readRDS("../data_to_export/tenx.mutant.integrated.RDS")
```

```{r}
## create a list of our mutant gene IDs
list_of_mutant_genes <- c("PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-1144800", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")
```

Read in gene annotations
```{r}
gene_annotations <- read.table("../data/Reference/GenesByTaxon_Summary.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)
dim(gene_annotations)

## convert _ to -
gene_annotations$Gene.ID <- gsub("_", "-", gene_annotations$Gene.ID)
```

# 3. Dimensionalty Reduction {.tabset}

We will now re-calculate the UMAP, PCA and diffusion map to visualise the data since the old visualisation used the variation in the whole dataset and so some of the variation in this set of cells was obscured.

ref: https://github.com/satijalab/seurat/issues/1883

## A. Recalculate PCA

The PCA is used as the basis of other dimensionality reductions so we will now recalculate this to get to our final UMAP.

First, run PCA again
```{r}
tenx.mutant.integrated.sex <- RunPCA(tenx.mutant.integrated.sex, npcs = 30, verbose = FALSE)
```

Then inspect the PCs
```{r}
ElbowPlot(tenx.mutant.integrated.sex, ndims = 30, reduction = "pca")
```

Have a quick look at the output
```{r}
DimPlot(tenx.mutant.integrated.sex, reduction = "pca", pt.size = 0.01, label = TRUE)
```

And determine what is male and female:
```{r}
FeaturePlot(tenx.mutant.integrated.sex, features = c("PBANKA-1319500", "PBANKA-0416100"), blend = TRUE, combine = TRUE, coord.fixed = TRUE, reduction = "pca")
```


```{r}
## extract the cell embeddings from the pca
mds <- as.data.frame(tenx.mutant.integrated.sex@reductions$pca@cell.embeddings)

## change the coordinates of UMAP 1 so they are reversed
## take only the first two PCs
mds <- mds[ ,c("PC_1", "PC_2")]
mds$PC_1 <- -mds$PC_1
mds$PC_2 <- -mds$PC_2

## change names of the cols 
colnames(mds) <- paste0("DIM_PC_", 1:2)

## make into a matrix so that it can be saved in Seurat
mds <- as.matrix(mds)

## store this optimsed UMAP in a custom dim slot
tenx.mutant.integrated.sex[["DIM_PCA"]] <- CreateDimReducObject(embeddings = mds, key = "DIM_PCA_", assay = DefaultAssay(tenx.mutant.integrated.sex))

## check
DimPlot(tenx.mutant.integrated.sex, label = TRUE, repel = FALSE, pt.size = 0.05, dims = c(1,2), reduction = "DIM_PCA") + coord_fixed()
```
Calculate new clusters 
```{r, fig.height = 3, fig.width = 5}
## generate new clusters at mid resolution
## 2
tenx.mutant.integrated.sex <- FindNeighbors(tenx.mutant.integrated.sex, dims = 1:11, reduction = "pca")
tenx.mutant.integrated.sex <- FindClusters(tenx.mutant.integrated.sex, resolution = 1, random.seed = 42, algorithm = 2)

## Plot
pca_plot <- DimPlot(tenx.mutant.integrated.sex, label = TRUE, repel = TRUE, pt.size = 0.5, dims = c(1,2), reduction = "DIM_PCA", group.by = "seurat_clusters") + coord_fixed() 
## view
HoverLocator(plot = pca_plot, information = FetchData(tenx.mutant.integrated.sex, vars = c("identity_combined", "seurat_clusters")))
```

```{r}
umap_clusters <- DimPlot(tenx.mutant.integrated.sex, label = TRUE, repel = TRUE, pt.size = 0.5, dims = c(1,2), reduction = "DIM_PCA")+
  coord_fixed() +
      theme_void() + 
scale_color_discrete_qualitative(palette = "Dark 3")

umap_clusters
```
save
```{r}
ggsave("../images_to_export/ALLCELLS_cluster_sex_branch_locations.png", plot = umap_clusters, device = "png", path = NULL, scale = 1, width = 10, height = 12, units = "cm", dpi = 300, limitsize = TRUE)
```

```{r, fig.width = 10, fig.length = 10}
## make list of genotypes
list_of_genotypes <- unique(tenx.mutant.integrated.sex@meta.data$identity_combined)
## redorder for better plotting
list_of_genotypes <- list_of_genotypes[c(1, 3, 2, 4, 11, 7, 8, 12, 5, 10, 6, 9)]

## make a blank list
list_plots_sex_highlight <- vector(mode = "list", length = length(list_of_genotypes))

## for loop
for(i in seq_along(list_of_genotypes)){
    ## make a list of cells to highlight - but for wild-type, include all cells of that genotype, not just ones excluded for sex ratio
  if (grepl("wild-type", list_of_genotypes[i]) == FALSE) {
  list_of_cells <- rownames(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$identity_combined == list_of_genotypes[i] & tenx.mutant.integrated.sex@meta.data$exclude_for_sex_ratio == FALSE), ]) } else
  {list_of_cells <- rownames(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$identity_combined == list_of_genotypes[i]), ])}
  ## make a plot
  pca_plot <- DimPlot(tenx.mutant.integrated.sex, label = FALSE, repel = TRUE, pt.size = 0.1, cells.highlight = list_of_cells, dims = c(1,2), reduction = "DIM_PCA") + 
  coord_fixed() + 
  scale_color_manual(values=c("#E2E2E2", "#31206E")) + 
  theme_void() + 
  labs(title = paste(list_of_genotypes[i])) + 
  theme(plot.title = element_text(hjust = 0.5, family="Arial", size = 15, face = "bold.italic"), legend.position = "none")
  ## add to the list
  list_plots_sex_highlight[[i]] <- pca_plot
}
```
plot
```{r, fig.height = 10, fig.width = 10}
## this function writes the next bit of code for you
## put it into the console and paste the response
#ploty <- c()
#for(i in seq_along(list_of_genotypes)){
#  ploty <- paste0(ploty, "list_plots_sex_highlight[[", i, "]]", " + ")
#}

## plot
composite_cell_locations <- plot_grid(list_plots_sex_highlight[[1]] + theme(plot.title = element_text(hjust = 0.5, family="Arial", size = 13, face = "bold"), legend.position = "none"), 
                                      list_plots_sex_highlight[[2]] + theme(plot.title = element_text(hjust = 0.5, family="Arial", size = 13, face = "bold"), legend.position = "none"), 
                                      list_plots_sex_highlight[[3]], 
                                      list_plots_sex_highlight[[4]], 
                                      list_plots_sex_highlight[[5]], 
                                      list_plots_sex_highlight[[6]], 
                                      list_plots_sex_highlight[[7]], 
                                      list_plots_sex_highlight[[8]], 
                                      list_plots_sex_highlight[[9]], 
                                      list_plots_sex_highlight[[10]], 
                                      list_plots_sex_highlight[[11]], 
                                      list_plots_sex_highlight[[12]], 
                                      nrow = 2)

composite_cell_locations
```

save
```{r}
ggsave("../images_to_export/ALLCELLS_mutant_cell_locations.png", plot = composite_cell_locations, device = "png", path = NULL, scale = 1, width = 30, height = 20, units = "cm", dpi = 300, limitsize = TRUE)
```

## Pseudotime

```{r}
## make a new Seurat of this
seurat.object.sex <- tenx.mutant.integrated.sex

## extract counts and pheno:
## the reason we use the integrated and then subsetted is because these cells have been normalised whereas the cells in pb_sex_filtered have not been normalised (well they have but with doublets in them)
## with 10x only cells: all.equal(as.data.frame(counts(monocle.object)), as.data.frame(as.matrix(GetAssayData(seurat.object, assay = "RNA", slot = "counts")))) returns TRUE and also returns true when you change the slot input to "counts" and use monocle to norm it with method "log"
data <- as(as.matrix(GetAssayData(seurat.object.sex, assay = "RNA", slot = "counts")), 'sparseMatrix')
## make phenodata
pd <- data.frame(seurat.object.sex@meta.data)
## keep only the columns that are relevant in metadata
#pData <- pd %>% select(orig.ident, nCount_RNA, nFeature_RNA)
## make gene metadata
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

## Construct monocle cds
monocle.object.sex <- new_cell_data_set(expression_data = data, cell_metadata = pd, gene_metadata = fData)

## preprocess
monocle.object.sex = preprocess_cds(monocle.object.sex, num_dim = 50, norm_method = "log")
### if using integrated data:
# norm_method = "none", alignment_group = "~ experiment"

## plot jack straw plot
#plot_pc_variance_explained(monocle.object)

#monocle.object = reduce_dimension(monocle.object, reduction_method = "UMAP", preprocess_method = "PCA", umap.metric = "euclidean", umap.n_neighbors = 50, umap.min_dist = 0.5, verbose = FALSE)

#plot_cells(monocle.object, color_cells_by="experiment")

## graph learning

## add UMAP from Seurat
monocle.object.sex@int_colData@listData$reducedDims@listData[["UMAP"]] <- seurat.object.sex@reductions[["DIM_PCA"]]@cell.embeddings
## if you want the old UMAP from the original all cells one, use: "DIM_UMAP"

## cluster
## this is essential to run the learn_graph function later on
monocle.object.sex = cluster_cells(monocle.object.sex)

## plot initial clustering by monocle
#plot_cells(monocle.object, color_cells_by="cluster", group_cells_by="partition", x = 2, y = 1)

## map pseudotime
monocle.object.sex = learn_graph(monocle.object.sex, learn_graph_control=list(ncenter=200, minimal_branch_len = 10), use_partition = FALSE)
# learn_graph_control=list(ncenter=500) - play with this parameter - lower tends to give fewer branches and higher tends to give more
# 500 - old analysis
# 250 - new analysis 

##200

## Plot cells
plot_cells(monocle.object.sex, color_cells_by="post_integration_clusters", group_cells_by="partition", x = 1, y = 2)
```

Redefine the identities of the male and female cells 

male
```{r}
monocle.object_male <- choose_graph_segments(monocle.object.sex)
```
female
```{r}
monocle.object_female <- choose_graph_segments(monocle.object.sex)
```
bipotential
```{r}
monocle.object_bipot <- choose_graph_segments(monocle.object.sex)
```

check
```{r}
df_freq <- data.frame(table(c(colnames(monocle.object_male), colnames(monocle.object_female), colnames(monocle.object_bipot))))
paste("number of cells in seurat object is", length(colnames(monocle.object.sex)), ". The number of cells selected here with an identitity is", dim(df_freq)[1])
df_freq <- df_freq[df_freq$Freq > 1, ]
df_freq
```
Inspect where these missing cells are:
```{r}
# '%ni%' <- Negate('%in%')
# 
# not_assigned_cells <- colnames(monocle.object)[colnames(monocle.object) %ni% c(colnames(monocle.object_male), colnames(monocle.object_female), colnames(monocle.object_bipot), colnames(monocle.object_asex), colnames(monocle.object_asex_fate))]
# 
# DimPlot(seurat.object, repel = TRUE, label.size = 5, pt.size = 0.5, cells.highlight = not_assigned_cells, dims = c(2,1), reduction = "DIM_UMAP") +
#   coord_fixed() + 
#   scale_color_manual(values=c("#000000", "#f54e1e"))
```

```{r}
## raw numbers for each identity
table(monocle.object_male@colData$identity_combined)
table(monocle.object_female@colData$identity_combined)
table(monocle.object_bipot@colData$identity_combined)

## remove cells not sorted unbiasedly
table(monocle.object_male@colData[monocle.object_male@colData$exclude_for_sex_ratio == FALSE & !is.na(monocle.object_male@colData$exclude_for_sex_ratio), ]$identity_combined)
table(monocle.object_female@colData[monocle.object_female@colData$exclude_for_sex_ratio == FALSE & !is.na(monocle.object_female@colData$exclude_for_sex_ratio), ]$identity_combined)
table(monocle.object_bipot@colData[monocle.object_bipot@colData$exclude_for_sex_ratio == FALSE & !is.na(monocle.object_bipot@colData$exclude_for_sex_ratio), ]$identity_combined)

## correct for clusters
m_meta <- monocle.object_male@colData
m_meta <- m_meta[m_meta$exclude_for_sex_ratio == FALSE & !is.na(m_meta$exclude_for_sex_ratio), ]
m_meta <- m_meta[which(m_meta$seurat_clusters %in% c(5, 10, 4, 9, 12, 16)), ]
table(m_meta$identity_combined)

f_meta <- monocle.object_female@colData
f_meta <- f_meta[f_meta$exclude_for_sex_ratio == FALSE & !is.na(f_meta$exclude_for_sex_ratio), ]
f_meta <- f_meta[which(f_meta$seurat_clusters %in% c(14, 15, 13, 8, 11, 7, 0)), ]
table(f_meta$identity_combined)

b_meta <- monocle.object_bipot@colData
b_meta <- b_meta[b_meta$exclude_for_sex_ratio == FALSE & !is.na(b_meta$exclude_for_sex_ratio), ]
b_meta <- b_meta[which(b_meta$seurat_clusters %in% c(1, 2, 3, 6)), ]
table(b_meta$identity_combined)
```


```{r}
## create annotation dataframe from these results:
df_monocle_sexes <- rbind(data.frame("cell_name" = colnames(monocle.object_male), "sex" = rep("Male", length(colnames(monocle.object_male)))),
                          data.frame("cell_name" = colnames(monocle.object_female), "sex" = rep("Female", length(colnames(monocle.object_female)))),
                          data.frame("cell_name" = colnames(monocle.object_bipot), "sex" = rep("Bipotential", length(colnames(monocle.object_bipot))))
                          )

dim(df_monocle_sexes)

## order like the metadata
df_monocle_sexes <- df_monocle_sexes[match(rownames(monocle.object.sex@colData), df_monocle_sexes$cell_name), ]

## add this back into the monocle object
monocle.object.sex@colData$Sexes_monocle <- df_monocle_sexes$sex
```

#### Pseudotime Calculation
```{r}
## Order the cells and calculate pseudotime
monocle.object.sex = order_cells(monocle.object.sex)

## Plot
umap_pt <- plot_cells(monocle.object.sex, color_cells_by = "pseudotime", label_cell_groups=FALSE, cell_size = 1, x = 1, y = 2, label_branch_points=FALSE, label_leaves=FALSE, label_groups_by_cluster=FALSE, label_roots = FALSE) +
  coord_fixed() +
  theme_void() +
  labs(title = "Pseudotime") +
  theme(plot.title = element_text(hjust = 0.5, size=15), legend.position="right", legend.title=element_text (size=10), legend.text=element_text(size=10)) + 
  guides(colour = guide_colourbar(barwidth = 0.5, barheight = 10, title = "Pseudotime"))

## view
umap_pt
```

add pt to monocle
```{r}
## extract pt values
pt_values <- as.data.frame(pseudotime(monocle.object.sex, reduction_method = "UMAP"))

## add to monocle
monocle.object.sex@colData$pseudotime <- pt_values[ ,1]


## add to seurat
#tenx.mutant.integrated.sex <- AddMetaData(tenx.mutant.integrated.sex, pt_values, "pt_values")
```

```{r}
## plot
##extract pt values
df_pt_id <- monocle.object.sex@colData[,c("pseudotime", "Sexes_monocle")]
## extract UMAP coords
df_umap_plot <- tenx.mutant.integrated.sex@reductions[["DIM_PCA"]]@cell.embeddings
df_umap_plot <- merge(df_umap_plot, df_pt_id, by=0, all=TRUE)

## add tree
##The tree for monocle is located here:
# monocle.object@principal_graph_aux[["UMAP"]]$dp_mst 
ica_space_df <- t(monocle.object.sex@principal_graph_aux[["UMAP"]]$dp_mst) %>%
      as.data.frame() %>%
      dplyr::select_(prin_graph_dim_1 = "DIMPCA_1", prin_graph_dim_2 = "DIMPCA_2") %>%
      dplyr::mutate(sample_name = rownames(.),
                    sample_state = rownames(.))

dp_mst <- monocle.object.sex@principal_graph[["UMAP"]]

edge_df <- dp_mst %>%
      igraph::as_data_frame() %>%
      dplyr::select_(source = "from", target = "to") %>%
      dplyr::left_join(ica_space_df %>%
                         dplyr::select_(
                           source="sample_name",
                           source_prin_graph_dim_1="prin_graph_dim_1",
                           source_prin_graph_dim_2="prin_graph_dim_2"),
                       by = "source") %>%
      dplyr::left_join(ica_space_df %>%
                         dplyr::select_(
                           target="sample_name",
                           target_prin_graph_dim_1="prin_graph_dim_1",
                           target_prin_graph_dim_2="prin_graph_dim_2"),
                       by = "target")

## make ggplot
umap_id_pt <- ggplot(df_umap_plot, aes(x = DIMPCA_1, y = DIMPCA_2)) + 
                     geom_point(aes(color = pseudotime), size = 0.1) +
                     scale_colour_viridis(option = "plasma") +
                     theme_void() +
                     coord_fixed() +
                     geom_segment(aes_string(x="source_prin_graph_dim_1",
                                     y="source_prin_graph_dim_2",
                                     xend="target_prin_graph_dim_1",
                                     yend="target_prin_graph_dim_2"),
                          data=edge_df) +
                     theme(plot.title = element_text(hjust = 0.5, family="Arial", size = 13, face = "bold")) +
                     labs(title = "Pseudotime")

umap_id_pt
```

plot of cell identity:
```{r, fig.height = 4, fig.width = 4}
## extract meta data
df_pca <-tenx.mutant.integrated.sex@meta.data
## make new col
df_pca$assignment <- "unassigned"

## now add other annotations
## correct for clusters
## the problem with this approach is that cells that are na for unbiased sorting are excluded
#df_pca$assignment[which(rownames(df_pca) %in% rownames(m_meta))] <- "male"
#df_pca$assignment[which(rownames(df_pca) %in% rownames(f_meta))] <- "female"
#df_pca$assignment[which(rownames(df_pca) %in% rownames(b_meta))] <- "bipoential"
## correct for clusters
m_meta_2 <- monocle.object_male@colData
m_meta_2 <- m_meta_2[which(m_meta_2$seurat_clusters %in% c(5, 10, 4, 9, 12, 16)), ]

f_meta_2 <- monocle.object_female@colData
f_meta_2 <- f_meta_2[which(f_meta_2$seurat_clusters %in% c(14, 15, 13, 8, 11, 7, 0)), ]

b_meta_2 <- monocle.object_bipot@colData
b_meta_2 <- b_meta_2[which(b_meta_2$seurat_clusters %in% c(1, 2, 3, 6)), ]

df_pca$assignment[which(rownames(df_pca) %in% rownames(m_meta_2))] <- "male"
df_pca$assignment[which(rownames(df_pca) %in% rownames(f_meta_2))] <- "female"
df_pca$assignment[which(rownames(df_pca) %in% rownames(b_meta_2))] <- "progenitor"

## add back to meta data
tenx.mutant.integrated.sex <- AddMetaData(tenx.mutant.integrated.sex, df_pca$assignment, col.name = "assignment")

## remove these objects to save space
rm(m_meta_2, f_meta_2, b_meta_2)

## make a custom pal
# 1 = blue - "#0052c5"
# 2 = red - "#a52b1e"
# 3 = green - "#016c00"
# 4 = yellow - "#ffe400"
pal_sex <- c("#016c00", "#a52b1e", "#ffe400", "#E7E8EA")

UMAP_identity <- DimPlot(tenx.mutant.integrated.sex, label = FALSE, repel = TRUE, pt.size = 0.5, group.by = "assignment", dims = c(1,2), reduction = "DIM_PCA") +
  coord_fixed() + 
  scale_colour_manual(values=pal_sex) + 
  theme_void() + 
  #theme(legend.position = "none")
  ## add sex symbols
  annotate("text", x = 30, y = -50, label = male_symbol, size=7, color="#a52b1e") + 
  annotate("text", x = 50, y = -10, label = female_symbol, size=7, color="#016c00") +
  labs(title = '')

## print
UMAP_identity
```


plot pseudotime vs. genotype
```{r}
## extract sexes
male_df <- as.data.frame(monocle.object.sex@colData[which(monocle.object.sex@colData$Sexes_monocle == "Male"), ])
female_df <- as.data.frame(monocle.object.sex@colData[which(monocle.object.sex@colData$Sexes_monocle == "Female"), ])

## then only include cells that are:
## 1. unbiasedly sorted
## 2. in the right cluster
female_df <- female_df[female_df$exclude_for_sex_ratio == FALSE | is.na(female_df$exclude_for_sex_ratio), ]
female_df <- female_df[which(female_df$seurat_clusters %in% c(14, 15, 13, 8, 11, 7, 0)), ]
male_df <- male_df[male_df$exclude_for_sex_ratio == FALSE | is.na(male_df$exclude_for_sex_ratio), ]
male_df <- male_df[which(male_df$seurat_clusters %in% c(5, 10, 4, 9, 12, 16)), ]

## define the dataframes
male_df$identity_combined <- factor(male_df$identity_combined, levels = rev(c("md1", "md2", "md3", "md4", "md5", "gd1", "fd1", "fd2", "fd3", "fd4",  "wild-type (10x)", "wild-type (Smart-seq2)")))
female_df$identity_combined <- factor(female_df$identity_combined, levels = rev(c("md1", "md2", "md3", "md4", "md5", "gd1", "fd1", "fd2", "fd3", "fd4", "wild-type (10x)", "wild-type (Smart-seq2)")))
```

```{r, fig.width = 10, fig.height = 5}
library(ggridges)
## plot females 
p1 <- ggplot(female_df, aes(x = pseudotime, y =  identity_combined, fill = stat(x))) +
  geom_density_ridges_gradient(scale = 0.9, rel_min_height = 0.03,  quantile_lines = TRUE, quantiles = 2, point_alpha = 0.5, alpha = 0.8) +
  theme_classic() +
  scale_y_discrete(drop=FALSE) +
  labs(title = 'Female', x = "Female Branch Pseudotime", y = "Genotype") +
  scale_fill_viridis_c(name = "pseudotime", option = "C", alpha = 1) +
  theme(legend.position = "none", 
        panel.grid.major.y = element_line(size = (0.2), colour="grey"),
        axis.title.x=element_blank())

## plot males
p2 <- ggplot(male_df, aes(x = pseudotime, y =  identity_combined, fill = stat(x))) +
  geom_density_ridges_gradient(scale = 0.9, rel_min_height = 0.03,  quantile_lines = TRUE, quantiles = 2, point_alpha = 0.5, alpha = 0.8, na.rm = FALSE)  +
  theme_classic() +
  scale_y_discrete(drop=FALSE) +
  labs(title = 'Male', x = "Male Branch Pseudotime") +
  scale_fill_viridis_c(name = "pseudotime", option = "C", alpha = 1) +
  theme(legend.position = "none",
        panel.grid.major.y = element_line(size = (0.2), colour="grey"),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

plot_grid(p1, p2, nrow = 1, align = "h", axis = "b")
#library(egg)
#egg::ggarrange(p1, p2,  nrow = 1)

#grid.newpage()
#grid.draw(cbind(ggplotGrob(p1), ggplotGrob(p2), size = "last"))
```

```{r}
combined_df <- rbind(male_df, female_df)

combined_ridge_plots <- ggplot(combined_df, aes(x = pseudotime, y =  identity_combined, fill = stat(x))) +
  geom_density_ridges_gradient(scale = 0.9, rel_min_height = 0.03,  quantile_lines = TRUE, quantiles = 2, point_alpha = 0.5, alpha = 0.8) +
  theme_classic() +
  scale_y_discrete(drop=FALSE) +
  labs(title = '', x = "Pseudotime", y = "") +
  scale_fill_viridis_c(name = "pseudotime", option = "C", alpha = 1) +
  theme(legend.position = "none", 
        panel.grid.major.y = element_line(size = (0.2), colour="grey"),
        axis.title.x=element_blank()) + 
  facet_grid(cols = vars(Sexes_monocle))

combined_ridge_plots
```

```{r}
library(gridExtra)

combined_df <- rbind(male_df, female_df)
x <- as.data.frame(as.matrix.data.frame(table(combined_df$Sexes_monocle, combined_df$identity_combined)))
colnames(x) <- colnames(as.matrix(table(combined_df$Sexes_monocle, combined_df$identity_combined)))
rownames(x) <- rownames(as.matrix(table(combined_df$Sexes_monocle, combined_df$identity_combined)))
## transform
x <- t(x)
## reverse order of rows to match plots
x<- x[seq(dim(x)[1],1),]
ss <- tableGrob(x, theme = ttheme_minimal(base_family = "Arial"), rows=NULL)
grid.arrange(ss)
```

```{r}
plot_grid(combined_ridge_plots, ss, nrow = 1, rel_widths = c(3, 1))
```

```{r, fig.height = 11.7, fig.width = 8.3}
## A
composite_cell_locations <- plot_grid((UMAP_identity + labs(title=" ") + theme(plot.title = element_text(hjust = 0.5, family="Arial", size = 12, face = "bold"), legend.position = "none")),
                                      (umap_id_pt + theme(legend.position = "none")), 
                                      list_plots_sex_highlight[[3]], 
                                      list_plots_sex_highlight[[4]], 
                                      list_plots_sex_highlight[[5]], 
                                      list_plots_sex_highlight[[6]], 
                                      list_plots_sex_highlight[[7]], 
                                      list_plots_sex_highlight[[8]], 
                                      list_plots_sex_highlight[[9]], 
                                      list_plots_sex_highlight[[10]], 
                                      list_plots_sex_highlight[[11]], 
                                      list_plots_sex_highlight[[12]],
                                      (list_plots_sex_highlight[[1]] + theme(plot.title = element_text(hjust = 0.5, family="Arial", size = 12, face = "bold"), plot.subtitle = element_text(hjust = 0.5, family="Arial", size = 12, face = "bold"), legend.position = "none") + labs(title="wild-type", subtitle="(10x)")), 
                                      (list_plots_sex_highlight[[2]] + theme(plot.title = element_text(hjust = 0.5, family="Arial", size = 12, face = "bold"), plot.subtitle = element_text(hjust = 0.5, family="Arial", size = 12, face = "bold"), legend.position = "none") + labs(title="wild-type", subtitle="(Smart-seq2)")), 
                                      nrow = 2,
                                      axis = c("b")
                                      )

B <- plot_grid(combined_ridge_plots, ss, nrow = 1, rel_widths = c(3, 1))

## labels as uppercase letters:
#c(toupper(letters)[2:17])
# labels as roman numerals:
# c(tolower(as.roman(c(2:17))

Figure_publication <- plot_grid(composite_cell_locations, 
                                B,
                                ## add empty plot to give spacing
                                (ggplot() + theme_void()),
                                labels = c('', ''), 
                                label_size = 12, 
                                ncol = 1, 
                                nrow=3, 
                                rel_heights = c(1, 1, 1), 
                                rel_widths = c(1, 1, 1))

#ggdraw() +
#  draw_plot(composite_cell_locations, 0, .5, 1, .5) +
#  draw_plot(combined_ridge_plots, 0, 0, .5, .5) +
#  draw_plot(ss, .5, 0, .5, .5)

Figure_publication
```

save
```{r}
ggsave("../images_to_export/Figure_4.png", plot = Figure_publication, device = "png", path = NULL, scale = 1, width = 21, height = 29.7, units = "cm", dpi = 300, limitsize = TRUE)
```


# Differential expression

```{r}
table(tenx.mutant.integrated.sex@meta.data$identity_combined, tenx.mutant.integrated.sex$seurat_clusters)
```

```{r}
## make pal
#pal_de <- c(diverging_hcl(2, palette = "Berlin")[1],"#E2E2E2", diverging_hcl(2, palette = "Berlin")[2])

## make df of above table
df <- as.data.frame(table(tenx.mutant.integrated.sex@meta.data$identity_combined, tenx.mutant.integrated.sex$seurat_clusters))
## change names
names(df) <- c("Genotype", "Cluster", "Frequency")
## reorder factor levels
df$Genotype <- factor(df$Genotype,levels = rev(levels(df$Genotype)))

## add colour column for clusters actually compared
df$col <- "white"
df[df$Genotype == "md3" & df$Cluster == "4", ]$col <- "mutant"
df[df$Genotype == "md4" & df$Cluster == "12", ]$col <- "mutant"
df[df$Genotype == "md5" & df$Cluster == "10", ]$col <- "mutant"
df[df$Genotype == "gd1" & df$Cluster == "12", ]$col <- "mutant"
df[df$Genotype == "fd1" & df$Cluster == "8", ]$col <- "mutant"
df[df$Genotype == "fd2" & df$Cluster == c("8", "15"), ]$col <- "mutant"
df[df$Genotype == "fd3" & df$Cluster == "0", ]$col <- "mutant"
df[df$Genotype == "fd4" & df$Cluster == "0", ]$col <- "mutant"
df[(df$Genotype == "wild-type (10x)" | df$Genotype == "wild-type (Smart-seq2)") & (df$Cluster == "0" | df$Cluster == "4" | df$Cluster == "8" | df$Cluster == "10" | df$Cluster == "12" | df$Cluster == "15"), ]$col <- "wild-type"

de_table <- ggplot(df, aes(Cluster, Genotype)) +
    geom_tile(aes(fill = col), color = "black") + 
    geom_text(aes(label = round(Frequency, 1))) +
  coord_fixed() +
  theme_minimal() +
    scale_fill_manual(breaks = c("mutant", "wild-type"), values = c(diverging_hcl(2, palette = "Berlin")[2],"#ffffff", diverging_hcl(2, palette = "Berlin")[1])) +
  labs(fill="Used for DE analysis") + 
  theme(text = element_text(size = 15, color = "black"), legend.position="bottom")

de_table
```

```{r}
ggsave("../images_to_export/DE_table.png", plot = de_table, device = "png", path = NULL, scale = 1, width = 20, height = 30, units = "cm", dpi = 300, limitsize = TRUE)
```


From this, we should compare differential expression as such:

md3 - 4
md4 - 12
md5 - 10
gd1 - 12 or 16 (seems to be it's own cluster)?
fd1 - 8
fd2 - has it's own cluster of 15 - compare 15 to 8
fd3 - 0 - not many cells
fd4 - 0 - not many cells
* for fd3 and fd4 you could do other clusters and look at changes along dev.

Things to look for:

1. is the expression of the marker (in mutants that make it to the end of gametocytogenesis) in the 820 lines disturbed?
2. Are any of the other screen hits disturbed?
3. What is the enrichment of these genes in 

### md3

```{r}
cells.4 <- subset(tenx.mutant.integrated.sex, idents = "4")
DefaultAssay(cells.4) <- "RNA"
Idents(cells.4) <- "identity_combined"
md3_markers <- FindMarkers(cells.4, ident.1 = "md3", ident.2 = c("wild-type (10x)", "wild-type (Smart-seq2)"), test.use = "MAST", verbose = FALSE)
md3_markers <- md3_markers[md3_markers$p_val_adj < 0.05, ]
head(md3_markers, n = 15)
md3_markers_annotated <- merge(gene_annotations, md3_markers, by.x = "Gene.ID", by.y = 0)
View(md3_markers_annotated)
```

```{r}
VlnPlot(cells.4, features = c("PBANKA-1030100", "PBANKA-1206900"), group.by = "identity_combined", pt.size = 0, combine = FALSE, slot = "data", assay = "RNA")
```

```{r}
cells_to_plot <- rownames(tenx.mutant.integrated.sex@meta.data[tenx.mutant.integrated.sex@meta.data$identity_combined == c("wild-type (10x)", "wild-type (Smart-seq2)", "md3"), ])
FeaturePlot(tenx.mutant.integrated.sex, features = c("PBANKA-1030100", "PBANKA-1206900"), dims = c(1,2), reduction = "DIM_PCA", cells = cells_to_plot, split.by = "genotype_combined")
```


Some issues with actin 2 and beta tubulin which may prevent a fully fertile gametocyte

## md4

```{r}
cells.12 <- subset(tenx.mutant.integrated.sex, idents = "12")
DefaultAssay(cells.12) <- "RNA"
Idents(cells.12) <- "identity_combined"
md4_markers <- FindMarkers(cells.12, ident.1 = "md4", ident.2 = c("wild-type (10x)", "wild-type (Smart-seq2)"), test.use = "MAST", verbose = FALSE)
md4_markers <- md4_markers[md4_markers$p_val_adj < 0.05, ]
head(md4_markers, n = 15)
md4_markers_annotated <- merge(gene_annotations, md4_markers, by.x = "Gene.ID", by.y = 0)
View(md4_markers_annotated)
```

```{r}
VlnPlot(cells.12, features = c("PBANKA-1209800", "PBANKA-0211500", "PBANKA-1222900", "PBANKA-1312700"), group.by = "identity_combined", pt.size = 0, combine = FALSE, slot = "data", assay = "RNA")
```

## md5

```{r}
cells.10 <- subset(tenx.mutant.integrated.sex, idents = "10")
DefaultAssay(cells.10) <- "RNA"
Idents(cells.10) <- "identity_combined"
md5_markers <- FindMarkers(cells.10, ident.1 = "md5", ident.2 = c("wild-type (10x)", "wild-type (Smart-seq2)"), test.use = "MAST", verbose = FALSE)
md5_markers <- md5_markers[md5_markers$p_val_adj < 0.05, ]
head(md5_markers, n = 15)
md5_markers_annotated <- merge(gene_annotations, md5_markers, by.x = "Gene.ID", by.y = 0)
View(md5_markers_annotated)
```

## gd1

```{r}
cells.12 <- subset(tenx.mutant.integrated.sex, idents = "12")
DefaultAssay(cells.12) <- "RNA"
Idents(cells.12) <- "identity_combined"
gd1_markers <- FindMarkers(cells.12, ident.1 = "gd1", ident.2 = c("wild-type (10x)", "wild-type (Smart-seq2)"), test.use = "MAST", verbose = FALSE)
gd1_markers <- gd1_markers[gd1_markers$p_val_adj < 0.05, ]
head(gd1_markers, n = 15)
gd1_markers_annotated <- merge(gene_annotations, gd1_markers, by.x = "Gene.ID", by.y = 0)
View(gd1_markers_annotated)
```

## fd1

```{r}
cells.8 <- subset(tenx.mutant.integrated.sex, idents = "8")
DefaultAssay(cells.8) <- "RNA"
Idents(cells.8) <- "identity_combined"
fd1_markers <- FindMarkers(cells.8, ident.1 = "fd1", ident.2 = c("wild-type (10x)", "wild-type (Smart-seq2)"), test.use = "MAST", verbose = FALSE)
fd1_markers <- fd1_markers[fd1_markers$p_val_adj < 0.05, ]
head(fd1_markers, n = 15)
fd1_markers_annotated <- merge(gene_annotations, fd1_markers, by.x = "Gene.ID", by.y = 0)
View(fd1_markers_annotated)
```

## fd2 

```{r}
cells.15.8 <- subset(tenx.mutant.integrated.sex, idents = c("15", "8"))
DefaultAssay(cells.15.8) <- "RNA"
Idents(cells.15.8) <- "identity_combined"
fd2_markers <- FindMarkers(cells.15.8, ident.1 = "fd2", ident.2 = c("wild-type (10x)", "wild-type (Smart-seq2)"), test.use = "MAST", verbose = FALSE)
fd2_markers <- fd2_markers[fd2_markers$p_val_adj < 0.05, ]
head(fd2_markers, n = 15)
fd2_markers_annotated <- merge(gene_annotations, fd2_markers, by.x = "Gene.ID", by.y = 0)
View(fd2_markers_annotated)
```

## fd3 

```{r}
cells.0 <- subset(tenx.mutant.integrated.sex, idents = "0")
DefaultAssay(cells.0) <- "RNA"
Idents(cells.0) <- "identity_combined"
fd3_markers <- FindMarkers(cells.0, ident.1 = "fd3", ident.2 = c("wild-type (10x)", "wild-type (Smart-seq2)"), test.use = "MAST", verbose = FALSE)
fd3_markers <- fd3_markers[fd3_markers$p_val_adj < 0.05, ]
head(fd3_markers, n = 15)
fd3_markers_annotated <- merge(gene_annotations, fd3_markers, by.x = "Gene.ID", by.y = 0)
View(fd3_markers_annotated)
```

## fd4

```{r}
cells.0 <- subset(tenx.mutant.integrated.sex, idents = "0")
DefaultAssay(cells.0) <- "RNA"
Idents(cells.0) <- "identity_combined"
fd4_markers <- FindMarkers(cells.0, ident.1 = "fd4", ident.2 = c("wild-type (10x)", "wild-type (Smart-seq2)"), test.use = "MAST", verbose = FALSE)
fd4_markers <- fd4_markers[fd4_markers$p_val_adj < 0.05, ]
head(fd4_markers, n = 15)
fd4_markers_annotated <- merge(gene_annotations, fd4_markers, by.x = "Gene.ID", by.y = 0)
View(fd4_markers_annotated)
```

save results of DE into excel
```{r}
library(xlsx)
write.xlsx(md3_markers_annotated, file="../data_to_export/DE_analysis.xlsx", sheetName="md3", row.names=FALSE)
write.xlsx(md4_markers_annotated, file="../data_to_export/DE_analysis.xlsx", sheetName="md4", append=TRUE, row.names=FALSE)
write.xlsx(md5_markers_annotated, file="../data_to_export/DE_analysis.xlsx", sheetName="md5", append=TRUE, row.names=FALSE)
write.xlsx(gd1_markers_annotated, file="../data_to_export/DE_analysis.xlsx", sheetName="gd1", append=TRUE, row.names=FALSE)
write.xlsx(fd1_markers_annotated, file="../data_to_export/DE_analysis.xlsx", sheetName="fd1", append=TRUE, row.names=FALSE)
write.xlsx(fd2_markers_annotated, file="../data_to_export/DE_analysis.xlsx", sheetName="fd2", append=TRUE, row.names=FALSE)
write.xlsx(fd3_markers_annotated, file="../data_to_export/DE_analysis.xlsx", sheetName="fd3", append=TRUE, row.names=FALSE)
write.xlsx(fd4_markers_annotated, file="../data_to_export/DE_analysis.xlsx", sheetName="fd4", append=TRUE, row.names=FALSE)
```

how many DE genes per condition?

```{r}
dim(md3_markers_annotated)[1]
dim(md4_markers_annotated)[1]
dim(md5_markers_annotated)[1]
dim(gd1_markers_annotated)[1]
dim(fd1_markers_annotated)[1]
dim(fd2_markers_annotated)[1]
dim(fd3_markers_annotated)[1]
dim(fd4_markers_annotated)[1]
```

with filters of 2 fold change up or down (e.g. 0.5  > logFC > 1)

```{r}
dim(md3_markers_annotated[md3_markers_annotated$avg_logFC > 1 | md3_markers_annotated$avg_logFC < 0.5, ])[1]
dim(md4_markers_annotated[md4_markers_annotated$avg_logFC > 1 | md4_markers_annotated$avg_logFC < 0.5, ])[1]
dim(md5_markers_annotated[md5_markers_annotated$avg_logFC > 1 | md5_markers_annotated$avg_logFC < 0.5, ])[1]
dim(gd1_markers_annotated[gd1_markers_annotated$avg_logFC > 1 | gd1_markers_annotated$avg_logFC < 0.5, ])[1]
dim(fd1_markers_annotated[fd1_markers_annotated$avg_logFC > 1 | fd1_markers_annotated$avg_logFC < 0.5, ])[1]
dim(fd2_markers_annotated[fd2_markers_annotated$avg_logFC > 1 | fd2_markers_annotated$avg_logFC < 0.5, ])[1]
dim(fd3_markers_annotated[fd3_markers_annotated$avg_logFC > 1 | fd3_markers_annotated$avg_logFC < 0.5, ])[1]
dim(fd4_markers_annotated[fd4_markers_annotated$avg_logFC > 1 | fd4_markers_annotated$avg_logFC < 0.5, ])[1]
```

filter
```{r}
md3_markers_annotated_filtered <- md3_markers_annotated[md3_markers_annotated$avg_logFC > 1 | md3_markers_annotated$avg_logFC < 0.5, ]
md4_markers_annotated_filtered <- md4_markers_annotated[md4_markers_annotated$avg_logFC > 1 | md4_markers_annotated$avg_logFC < 0.5, ]
md5_markers_annotated_filtered <- md5_markers_annotated[md5_markers_annotated$avg_logFC > 1 | md5_markers_annotated$avg_logFC < 0.5, ]
gd1_markers_annotated_filtered <- gd1_markers_annotated[gd1_markers_annotated$avg_logFC > 1 | gd1_markers_annotated$avg_logFC < 0.5, ]
fd1_markers_annotated_filtered <- fd1_markers_annotated[fd1_markers_annotated$avg_logFC > 1 | fd1_markers_annotated$avg_logFC < 0.5, ]
fd2_markers_annotated_filtered <- fd2_markers_annotated[fd2_markers_annotated$avg_logFC > 1 | fd2_markers_annotated$avg_logFC < 0.5, ]
fd3_markers_annotated_filtered <- fd3_markers_annotated[fd3_markers_annotated$avg_logFC > 1 | fd3_markers_annotated$avg_logFC < 0.5, ]
fd4_markers_annotated_filtered <- fd4_markers_annotated[fd4_markers_annotated$avg_logFC > 1 | fd4_markers_annotated$avg_logFC < 0.5, ]
```


basic venn

```{r}
library(ggvenn)
## set up palette
## there are 8 DE genotypes 
qualitative_hcl(8, palette = "Pastel 1")

## make lists 
a <- list(`md3` = md3_markers_annotated_filtered$Gene.ID,
          `md4` = md4_markers_annotated_filtered$Gene.ID,
          `md5` = md5_markers_annotated_filtered$Gene.ID,
          `gd1` = gd1_markers_annotated_filtered$Gene.ID)
## plot
venn_male_md3 <- ggvenn(a, 
       c("md3", "md4", "md5", "gd1"),
       fill_color = c(qualitative_hcl(8, palette = "Pastel 1")[1], qualitative_hcl(8, palette = "Pastel 1")[2], qualitative_hcl(8, palette = "Pastel 1")[3], qualitative_hcl(8, palette = "Pastel 1")[4]),
       stroke_size = 0.5, set_name_size = 4,show_percentage = FALSE,
       fill_alpha = 0.5
       ) 
venn_male_md3
```
save
```{r}
ggsave("../images_to_export/venn_male_md3.png", plot = venn_male_md3, device = "png", path = NULL, scale = 1, width = 5, height = 5, units = "cm", dpi = 300, limitsize = TRUE)
```

```{r}
library("colorspace")
## make lists 
a <- list(`md4` = md4_markers_annotated_filtered$Gene.ID,
          `md5` = md5_markers_annotated_filtered$Gene.ID,
          `gd1` = gd1_markers_annotated_filtered$Gene.ID)
## plot
venn_male <- ggvenn(a, 
       c("md4", "md5", "gd1"),
       fill_color = c(qualitative_hcl(8, palette = "Pastel 1")[2], qualitative_hcl(8, palette = "Pastel 1")[3], qualitative_hcl(8, palette = "Pastel 1")[4]),
       stroke_size = 0.5, 
       set_name_size = 4,
       show_percentage = FALSE,
       fill_alpha = 0.5
       )
venn_male
```
save
```{r}
ggsave("../images_to_export/venn_male.png", plot = venn_male, device = "png", path = NULL, scale = 1, width = 5, height = 5, units = "cm", dpi = 300, limitsize = TRUE)
```

```{r}
library("colorspace")
## make lists 
a <- list(`fd1` = fd1_markers_annotated_filtered$Gene.ID,
          `fd2` = fd2_markers_annotated_filtered$Gene.ID,
          `fd3` = fd3_markers_annotated_filtered$Gene.ID,
          `fd4` = fd4_markers_annotated_filtered$Gene.ID)
## plot
venn_female <- ggvenn(a, 
       #c("fd1", "fd2", "fd3", "fd4"),
       fill_color = c(qualitative_hcl(8, palette = "Pastel 1")[5], qualitative_hcl(8, palette = "Pastel 1")[6], qualitative_hcl(8, palette = "Pastel 1")[7], qualitative_hcl(8, palette = "Pastel 1")[8]),
       stroke_size = 0.5, 
       set_name_size = 4,
       show_percentage = FALSE,
       fill_alpha = 0.5
       )
venn_female
```
save
```{r}
ggsave("../images_to_export/venn_female.png", plot = venn_female, device = "png", path = NULL, scale = 1, width = 5, height = 5, units = "cm", dpi = 300, limitsize = TRUE)
```

### DE comparison figures

```{r, fig.width = 10, fig.length = 10}
## make list of genotypes
list_of_genotypes <- unique(tenx.mutant.integrated.sex@meta.data$identity_combined)
## redorder for better plotting and remove wt, md1, and md2
list_of_genotypes <- list_of_genotypes[c(11, 7, 8, 12, 5, 10, 6, 9)]
## make a list of clusters to highlight for each genotype
list_of_clusters <- list(c("4"), c("12"), c("10"), c("12"), c("8"), c("15", "8"), c("0"), c("0"))

## make a blank list for plots
list_plots_de_highlight <- vector(mode = "list", length = length(list_of_genotypes))

## make pal
pal_de <- c(diverging_hcl(2, palette = "Berlin")[2],"#E2E2E2", diverging_hcl(2, palette = "Berlin")[1])

## for loop
for(i in seq_along(list_of_genotypes)){
    ## make a list of cells to highlight - but for wild-type, include all cells of that genotype, not just ones excluded for sex ratio
  umap_tx = tenx.mutant.integrated.sex@reductions[["DIM_PCA"]]@cell.embeddings
  umap_tx <- merge(umap_tx, tenx.mutant.integrated.sex@meta.data[,c("seurat_clusters", "identity_combined")], by=0, all=TRUE)
  ## make a new blank column
  umap_tx$col <- "not-profiled"
  ## add colours for each highlighted class
  umap_tx[umap_tx$seurat_clusters == list_of_clusters[[i]] & umap_tx$identity_combined == c("wild-type (10x)","wild-type (Smart-seq2)"), ]$col <- "wild-type"
  umap_tx[umap_tx$seurat_clusters == list_of_clusters[[i]] & umap_tx$identity_combined == list_of_genotypes[i], ]$col <- "mutant"
  ## make a size column 
  #umap_tx[umap_tx$col == "not-profiled", ]$pt_size <- "small"
  #umap_tx[umap_tx$col == "wild-type" | umap_tx$col == "mutant", ]$pt_size <- "big"
  ## order cells so that profiled cells are plotted last
  umap_tx <- rbind(umap_tx[umap_tx$col == "not-profiled", ], umap_tx[umap_tx$col == "wild-type", ], umap_tx[umap_tx$col == "mutant", ])
  ## make a plot
  pca_plot <- ggplot(umap_tx, aes(x = DIMPCA_1, y = DIMPCA_2)) +
              geom_point(aes(color = col, size = col, alpha = col)) +
              scale_colour_manual(values=pal_de) +
              scale_size_manual(values=c(3, 1, 3)) +
              scale_alpha_manual(values=c(0.5, 1, 0.5)) +
              coord_fixed() +
              theme_void() + 
              labs(title = paste(list_of_genotypes[i])) + 
              theme(plot.title = element_text(hjust = 0.5, family="Arial", size = 15, face = "bold.italic"), legend.position = "none")
  ## add to the list
  list_plots_de_highlight[[i]] <- pca_plot
}
```
plot
```{r, fig.height = 10, fig.width = 10}
## this function writes the next bit of code for you
## put it into the console and paste the response
#ploty <- c()
#for(i in seq_along(list_of_genotypes)){
#  ploty <- paste0(ploty, "list_plots_sex_highlight[[", i, "]]", " + ")
#}

## plot
composite_cell_locations <- plot_grid(list_plots_de_highlight[[1]], 
                                      list_plots_de_highlight[[2]], 
                                      list_plots_de_highlight[[3]], 
                                      list_plots_de_highlight[[4]], 
                                      list_plots_de_highlight[[5]], 
                                      list_plots_de_highlight[[6]], 
                                      list_plots_de_highlight[[7]], 
                                      list_plots_de_highlight[[8]], 
                                      nrow = 2)

composite_cell_locations
```

save
```{r}
ggsave("../images_to_export/ALLCELLS_de_cell_locations.png", plot = composite_cell_locations, device = "png", path = NULL, scale = 1, width = 20, height = 10, units = "cm", dpi = 300, limitsize = TRUE)
```

Assessing DE genes

```{r}
## make a list of dataframes so one can run for loops on these
list_of_DE_gene_lists <- 
```





























Run tSNE
```{r}
tenx.mutant.integrated.sex <- RunTSNE(tenx.mutant.integrated.sex, seed.use = 1234, perplexity = 200)
DimPlot(tenx.mutant.integrated.sex, reduction = "tsne", pt.size = 0.01, label = TRUE)
```

## B. UMAP

calculate UMAP
```{r, fig.height = 7, fig.width = 7}
## run UMAP
#tenx.mutant.integrated.sex <- RunUMAP(tenx.mutant.integrated.sex, reduction = "pca", dims = 1:15, n.neighbors = 20, seed.use = 1234, min.dist = 0.5, repulsion.strength = 0.05, reduction.name = "umapoptimised_post_repca")

tenx.mutant.integrated.sex <- RunUMAP(tenx.mutant.integrated.sex, reduction = "pca", dims = 1:11, seed.use = 1234, n.neighbors = 10, reduction.name = "umapoptimised_post_repca", reduction.key='umap_post_repca_')

## plot
DimPlot(tenx.mutant.integrated.sex, reduction = "umapoptimised_post_repca", label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "identity_combined") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))

DimPlot(tenx.mutant.integrated.sex, reduction = "umapoptimised_post_repca", label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, split.by = "genotype_combined") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))

DimPlot(tenx.mutant.integrated.sex, reduction = "umapoptimised_post_repca", label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, split.by = "experiment", group.by = "identity_combined") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))

FeaturePlot(tenx.mutant.integrated.sex, reduction = "umapoptimised_post_repca", pt.size = 0.01, features = "PBANKA-1319500") + coord_fixed()
```


check markers to orientate
```{r, fig.height = 4, fig.width = 10}
plots <- FeaturePlot(tenx.mutant.integrated.sex, features = c("PBANKA-1319500", "PBANKA-0416100"), blend = TRUE, combine = FALSE, coord.fixed = TRUE, reduction = "umapoptimised_post_repca")

plots[[3]] + NoLegend()  # Get just the co-expression plot, built-in legend is meaningless for this plot
plots[[4]] # Get just the key
CombinePlots(plots[3:4], legend = 'none', ncol =2, nrow = 1, rel_widths = c(2, 1), rel_heights = c(4,1)) # Stitch the co-expression and key plots together
```

inspect mutants in 13 that are in between sexes
```{r}
## get mutant cells
mutant_sex_cells <- rownames(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$genotype_combined == "Mutant"),])
                                                        
## subset object
mutant_only_seurat <- subset(tenx.mutant.integrated.sex, cells = mutant_sex_cells)

## plot
umap_mutant <- DimPlot(mutant_only_seurat, reduction = "umapoptimised_post_repca", label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5) +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))

## view
HoverLocator(plot = umap_mutant, information = FetchData(mutant_only_seurat, vars = c("ident", "identity_updated", "nFeature_RNA", "identity_combined")))
```

```{r}
DimPlot(mutant_only_seurat, label = TRUE, label.size = 8, repel = FALSE, pt.size = 0.5, dims = c(2,1), reduction = "DIM_UMAP") + 
     coord_fixed() +
     theme(legend.position="bottom", 
           axis.line=element_blank(),
           axis.text.x=element_blank(),
           axis.text.y=element_blank(),
           axis.ticks=element_blank(),
           axis.title.x=element_blank(),
           axis.title.y=element_blank()) + 
     guides(colour=guide_legend(nrow = 3, byrow = TRUE, override.aes = list(size=5)))
```

# 4. Clustering {.tabset}

### Investigate sub clustering of pre-branch clusters

Ultimately, we are looking for coexpression after the expression of AP2G:
```{r}
## plot
marker_gene_plot_AP2G <- FeaturePlot(tenx.mutant.integrated.sex, features = "PBANKA-1437500", coord.fixed = TRUE, min.cutoff = "q1", dims = c(2,1), reduction = "DIM_UMAP", pt.size = 1, order = TRUE) + 
  theme_void() + 
  labs(title = paste("AP2G Expression")) + 
  theme(plot.title = element_text(hjust = 0.5, family="Arial", size = 20, face = "bold")) + 
  scale_colour_gradientn(colours=c("#DCDCDC", plasma(30)))

##view
marker_gene_plot_AP2G
```
and we have the following clusters currently:

```{r, fig.height = 4, fig.width = 4}
## Plot
umap_cluster <- DimPlot(tenx.mutant.integrated.sex, label = TRUE, label.size = 8, repel = FALSE, pt.size = 0.5, dims = c(2,1), reduction = "DIM_UMAP") + 
  coord_fixed() +
  theme(legend.position="bottom", 
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()) + 
  guides(colour=guide_legend(nrow = 3, byrow = TRUE, override.aes = list(size=5)))

## print
umap_cluster
```

11 is the common sex branch so we will interrogate that branch

```{r}
## subset cluster 13 cells
cells_bipot <- rownames(tenx.mutant.integrated.sex@meta.data[tenx.mutant.integrated.sex@meta.data$seurat_clusters == 11 & tenx.mutant.integrated.sex@meta.data$genotype_combined == "WT", ])

## subset cluster 13
seurat_bipot <- subset(tenx.mutant.integrated.sex, cells = cells_bipot)
seurat_bipot

## re-PCA
seurat_bipot <- RunPCA(seurat_bipot, npcs = 30, verbose = FALSE)
ElbowPlot(seurat_bipot, ndims = 30, reduction = "pca")

## recluster
seurat_bipot <- FindNeighbors(seurat_bipot, dims = 1:15)
seurat_bipot <- FindClusters(seurat_bipot, resolution = 1, random.seed = 42, algorithm = 2)
DimPlot(seurat_bipot, reduction = "pca",  dims = c(2,1), label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "seurat_clusters") 

## plot cluster resolution = 1
## plot
DimPlot(seurat_bipot, reduction = "DIM_UMAP",  dims = c(2,1), label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "seurat_clusters") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))
```

2 and 1 are superimposed on the branch, lets find markers for each cluster

```{r}

# PBANKA-0828000         GCSKO-3  GD1

# PBANKA-1302700       GCSKO-oom  MD1 
# PBANKA-1447900        GCSKO-29  MD2
# PBANKA-0102400         GCSKO-2  MD3 
# PBANKA-0716500        GCSKO-19  MD4 
# PBANKA-0413400    GCSKO-10_820  MD5

# PBANKA-1454800        GCSKO-21  FD1
# PBANKA-0902300        GCSKO-13  FD2
# PBANKA-1418100        GCSKO-17  FD3   
# PBANKA-1435200        GCSKO-20  FD4 

# PBANKA-1437500 - AP2G - commitment

## find markers
seurat_bipot_markers <- FindAllMarkers(seurat_bipot, only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25, test.use = "MAST")

## inspect result
markers_subset <- seurat_bipot_markers %>% group_by(cluster) %>% top_n(n = 50, wt = avg_logFC) %>% filter(p_val_adj < 0.05)
markers_subset <- markers_subset[order(-markers_subset$avg_logFC), ]
markers_subset

## find markers
markers_subset_mutant <- markers_subset[which(markers_subset$gene %in% list_of_mutant_genes), ]
markers_subset_mutant

## plot
VlnPlot(seurat_bipot, features = c(markers_subset_mutant$gene, "PBANKA-1437500"), assay = "RNA")
```
Specifically look for markers between 0 and 2
```{r}
cluster_1_2_markers <- FindMarkers(seurat_bipot, ident.1 = 0, ident.2 = 2, only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25)

cluster_1_2_markers_subset <- cluster_1_2_markers %>% filter(p_val_adj < 0.05)
cluster_1_2_markers_subset <- cluster_1_2_markers_subset[order(-cluster_1_2_markers_subset$avg_logFC), ]
cluster_1_2_markers_subset
```

```{r}
## this is no longer needed as only wild-type cells are chosen.
## Just check that mutants aren't interfering  with the analysis i.e. the clusters don't just belong to a certain genotype or mutant cell
#table(seurat_bipot$seurat_clusters, seurat_bipot$identity_combined)
```

Do the same analysis on cluster 5 quickly
```{r}
## subset cluster 13 cells
cells_three <- rownames(tenx.mutant.integrated.sex@meta.data[tenx.mutant.integrated.sex@meta.data$seurat_clusters == 5, ])

## subset cluster 13
cells_three <- subset(tenx.mutant.integrated.sex, cells = cells_three)

## re-PCA
cells_three <- RunPCA(cells_three, npcs = 30, verbose = FALSE)
ElbowPlot(cells_three, ndims = 30, reduction = "pca")

## recluster
cells_three <- FindNeighbors(cells_three, dims = 1:5)
## first do a c(0.5,1,2) for resolution and then pick a sensible cluster number
cells_three <- FindClusters(cells_three, resolution = 0.5, random.seed = 42, algorithm = 2)
DimPlot(cells_three, reduction = "pca",  dims = c(2,1), label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "seurat_clusters") 

## plot cluster resolution = 1
## plot
DimPlot(cells_three, reduction = "DIM_UMAP",  dims = c(2,1), label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "seurat_clusters") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))
```

```{r}
# PBANKA-0828000         GCSKO-3  GD1

# PBANKA-1302700       GCSKO-oom  MD1 
# PBANKA-1447900        GCSKO-29  MD2
# PBANKA-0102400         GCSKO-2  MD3 
# PBANKA-0716500        GCSKO-19  MD4 
# PBANKA-0413400    GCSKO-10_820  MD5

# PBANKA-1454800        GCSKO-21  FD1
# PBANKA-0902300        GCSKO-13  FD2
# PBANKA-1418100        GCSKO-17  FD3   
# PBANKA-1435200        GCSKO-20  FD4 

# PBANKA-1437500 - AP2G - commitment

## find markers
cells_three_markers <- FindAllMarkers(cells_three, only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25)

## inspect result
markers_subset <- cells_three_markers %>% group_by(cluster) %>% top_n(n = 50, wt = avg_logFC) %>% filter(p_val_adj < 0.05)
markers_subset <- markers_subset[order(-markers_subset$avg_logFC), ]
markers_subset

## find markers
markers_subset_mutant <- markers_subset[which(markers_subset$gene %in% list_of_mutant_genes), ]
markers_subset_mutant

## plot
VlnPlot(cells_three, features = c(markers_subset_mutant$gene, "PBANKA-1437500"), assay = "RNA")
```

```{r}
markers_subset_annotated <- merge(markers_subset, gene_annotations,  by.x = "gene", by.y = "Gene.ID", all = FALSE)
markers_subset_annotated
```


Cluster 2 contains the male cells as this has md1 and ap2g in it. 

cluster 3 has histone h2b, histone 4, actin 1, so likley contains asexual cells

cluster 0 is potentially female as these genes have female-biased expression in the kasia data

cluster 1 genes were not screened so unknown identity

Then look at the co-expression of AP2-G and MD1
```{r}
cluster_2_cells <- rownames(cells_three@meta.data[cells_three@meta.data$seurat_clusters == "2",])
cells_three_2 <- subset(cells_three, cells = cluster_2_cells)

df_plot <- data.frame(t(data.frame(cells_three_2@assays$RNA[c("PBANKA-1302700", "PBANKA-1437500"), ])))

ggplot(df_plot, aes(PBANKA.1302700, PBANKA.1437500)) + geom_point()

rm(cells_three_2)
```

Do the same on cluster 7 

```{r}
## subset cluster 13 cells
cells_seven <- rownames(tenx.mutant.integrated.sex@meta.data[tenx.mutant.integrated.sex@meta.data$seurat_clusters == 7 & tenx.mutant.integrated.sex@meta.data$genotype_combined == "WT", ])

## subset cluster 13
cells_seven <- subset(tenx.mutant.integrated.sex, cells = cells_bipot)
cells_seven

## re-PCA
cells_seven <- RunPCA(cells_seven, npcs = 30, verbose = FALSE)
ElbowPlot(cells_seven, ndims = 30, reduction = "pca")

## recluster
cells_seven <- FindNeighbors(cells_seven, dims = 1:15)
cells_seven <- FindClusters(cells_seven, resolution = 1, random.seed = 42, algorithm = 2)
DimPlot(cells_seven, reduction = "pca",  dims = c(2,1), label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "seurat_clusters") 

## plot cluster resolution = 1
## plot
DimPlot(cells_seven, reduction = "DIM_UMAP",  dims = c(2,1), label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "seurat_clusters") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))
```
```{r}
# PBANKA-0828000         GCSKO-3  GD1

# PBANKA-1302700       GCSKO-oom  MD1 
# PBANKA-1447900        GCSKO-29  MD2
# PBANKA-0102400         GCSKO-2  MD3 
# PBANKA-0716500        GCSKO-19  MD4 
# PBANKA-0413400    GCSKO-10_820  MD5

# PBANKA-1454800        GCSKO-21  FD1
# PBANKA-0902300        GCSKO-13  FD2
# PBANKA-1418100        GCSKO-17  FD3   
# PBANKA-1435200        GCSKO-20  FD4 

# PBANKA-1437500 - AP2G - commitment

## find markers
cells_seven_markers <- FindAllMarkers(cells_seven, only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25)

## inspect result
markers_subset <- cells_seven_markers %>% group_by(cluster) %>% top_n(n = 50, wt = avg_logFC) %>% filter(p_val_adj < 0.05)
markers_subset <- markers_subset[order(-markers_subset$avg_logFC), ]
markers_subset

## find markers
markers_subset_mutant <- markers_subset[which(markers_subset$gene %in% list_of_mutant_genes), ]
markers_subset_mutant

## plot
#VlnPlot(cells_seven, features = c(markers_subset_mutant$gene, "PBANKA-1437500"), assay = "RNA")
```

```{r}
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# 
# BiocManager::install("slingshot")
library(slingshot)
library(RColorBrewer)

## extracts only 10x cells 
wt_cells <- rownames(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$identity_combined == "WT_10X"),])
wt_cells <- rownames(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$identity_combined == "WT_10X" & !tenx.mutant.integrated.sex@meta.data$seurat_clusters == "7"),])


## make a new Seurat of this
seurat.object <-subset(tenx.mutant.integrated.sex, cells = wt_cells)

## get UMAP coordinates
umap_coords <- seurat.object@reductions[["DIM_UMAP"]]@cell.embeddings
## old code: seurat.object@reductions$umapoptimised_post_repca@cell.embeddings
## new code: seurat.object@reductions[["DIM_UMAP"]]@cell.embeddings

## get clusters
#clusters <- as.list(seurat.object@meta.data$integrated_snn_res.4)
#names(clusters) <- rownames(seurat.object@meta.data)
#clusters <- as.list(clusters)
## cluster using kmeans
## you need to set a seed here to ensure the results are reproducible
set.seed(42)
clusters <- kmeans(umap_coords, centers = 13)$cluster

## plot
## make a nicer plot so we can interpret the clusters
df_plotting <- as.data.frame(cbind(umap_coords, clusters))
## change to character to make it discrete
df_plotting$clusters <- as.character(df_plotting$clusters)
## plot
ggplot(df_plotting, aes(x = DIMUMAP_1, y = DIMUMAP_2, colour = clusters)) + 
  geom_point() + 
  scale_colour_manual(values = rainbow(15)) + 
  theme_classic()


## initialise plot to prevent error
plot.new()

## slingshot to get lineages
lineage_uamp <- getLineages(umap_coords, clusters, start.clus = '5', end.clus = c('3', '16'))

## make a curve through lineage 
crv1 <- getCurves(lineage_uamp)

## set up the colour pal
nb.cols <- 18 
mycolors <- colorRampPalette(brewer.pal(9, "Set1"))(nb.cols)

## join points with line segments and plot
plot(umap_coords, col = mycolors[clusters], asp = 3, pch = 16)
lines(crv1, lwd = 3, col = 'black')
```
Visualise cells:
```{r, fig.height = 10, fig.width = 10}
## define cells
slingshot_results_df <- as.data.frame(slingPseudotime(crv1))
curve_one_cells <- rownames(slingshot_results_df[!is.na(slingshot_results_df$curve1), ])
curve_two_cells <- rownames(slingshot_results_df[!is.na(slingshot_results_df$curve2), ])
curve_three_cells <- rownames(slingshot_results_df[!is.na(slingshot_results_df$curve3), ])
curve_four_cells <- rownames(slingshot_results_df[!is.na(slingshot_results_df$curve4), ])

c1_plot <- DimPlot(seurat.object, repel = TRUE, label.size = 5, pt.size = 0.5, cells.highlight = curve_one_cells, dims = c(2,1), reduction = "DIM_UMAP") +
  coord_fixed() + 
  scale_color_manual(values=c("#000000", "#f54e1e"))

c2_plot <- DimPlot(seurat.object, repel = TRUE, label.size = 5, pt.size = 0.5, cells.highlight = curve_two_cells, dims = c(2,1), reduction = "DIM_UMAP") +
  coord_fixed() + 
  scale_color_manual(values=c("#000000", "#f54e1e"))

c3_plot <- DimPlot(seurat.object, repel = TRUE, label.size = 5, pt.size = 0.5, cells.highlight = curve_three_cells, dims = c(2,1), reduction = "DIM_UMAP") +
  coord_fixed() + 
  scale_color_manual(values=c("#000000", "#f54e1e"))

c4_plot <- DimPlot(seurat.object, repel = TRUE, label.size = 5, pt.size = 0.5, cells.highlight = curve_four_cells, dims = c(2,1), reduction = "DIM_UMAP") +
  coord_fixed() + 
  scale_color_manual(values=c("#000000", "#f54e1e"))

plot_grid(c1_plot, c2_plot, c3_plot, c4_plot, labels = c('curve 1', 'curve 2', 'curve 3', 'curve 4'), label_size = 12, 
                                ncol = 2, 
                                nrow=2
                            
                )
```



Add data to Seurat:
```{r}
## extract data to add to Seurat
## extract clusters
meta_data_to_add_from_slingshot <- data.frame(clusters_k_means_UMAP = clusters)
## Add pseudotimes
# check the length of each branch to see which curve is which using: sum(is.na(as.data.frame(slingPseudotime(crv1))$curve1))
# then inspect using the ggplot2 above to where males are - 
# tail(as.data.frame(slingPseudotime(crv1)), 100)
# tail(meta_data_to_add_from_slingshot, 100)
meta_data_to_add_from_slingshot$PT_Female_UMAP <- as.data.frame(slingPseudotime(crv1))$curve1
meta_data_to_add_from_slingshot$PT_Male_UMAP <- as.data.frame(slingPseudotime(crv1))$curve2
## add designation to SCE object
meta_data_to_add_from_slingshot$sex_UMAP <- "pre-det"
meta_data_to_add_from_slingshot$sex_UMAP[which(is.na(meta_data_to_add_from_slingshot$PT_Female_UMAP))] <- "male"
meta_data_to_add_from_slingshot$sex_UMAP[which(is.na(meta_data_to_add_from_slingshot$PT_Male_UMAP))] <- "female"

## if there are 3 curves in slingPseudotime(crv1):
#meta_data_to_add_from_slingshot$sex_UMAP[which(is.na(meta_data_to_add_from_slingshot$PT_Female_UMAP) & is.na(as.data.frame(slingPseudotime(crv1))$curve3))] <- "male"
#meta_data_to_add_from_slingshot$sex_UMAP[which(is.na(meta_data_to_add_from_slingshot$PT_Male_UMAP) & is.na(as.data.frame(slingPseudotime(crv1))$curve3))] <- "female"

## add clusters to SCE object
tenx.mutant.integrated.sex <- AddMetaData(tenx.mutant.integrated.sex, meta_data_to_add_from_slingshot)
```

```{r, fig.height = 5, fig.width = 10}
## plot
FeaturePlot(tenx.mutant.integrated.sex, label.size = 5, pt.size = 0.5, features = c("PT_Female_UMAP", "PT_Male_UMAP")) +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))
```



plot sex designations
```{r, fig.height = 7, fig.width = 7}
DimPlot(tenx.mutant.integrated.sex, label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "sex_UMAP", na.value = "white") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))
```




# 6. Monocle on sex cells {.tabset}

## calculate pseudotime and modules

#### Preparation
```{r}
## extracts only 10x cells and also remove cluster 0 cells 
wt_cells <- rownames(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$identity_combined == "WT_10X" & !tenx.mutant.integrated.sex@meta.data$seurat_clusters == "7"),])

## make a new Seurat of this
seurat.object <-subset(tenx.mutant.integrated.sex, cells = wt_cells)

## check that this is the same as the pb_sex_filtered object
#data_test <- as(as.matrix(GetAssayData(pb_sex_filtered, assay = "RNA", slot = "data")), 'sparseMatrix')
#is.equal
#is.identical

## extract counts and pheno:
## the reason we use the integrated and then subsetted is because these cells have been normalised whereas the cells in pb_sex_filtered have not been normalised (well they have but with doublets in them)
## with 10x only cells: all.equal(as.data.frame(counts(monocle.object)), as.data.frame(as.matrix(GetAssayData(seurat.object, assay = "RNA", slot = "counts")))) returns TRUE and also returns true when you change the slot input to "counts" and use monocle to norm it with method "log"
data <- as(as.matrix(GetAssayData(seurat.object, assay = "RNA", slot = "data")), 'sparseMatrix')
## make phenodata
pd <- data.frame(seurat.object@meta.data)
## keep only the columns that are relevant in metadata
#pData <- pd %>% select(orig.ident, nCount_RNA, nFeature_RNA)
## make gene metadata
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

## Construct monocle cds
monocle.object <- new_cell_data_set(expression_data = data, cell_metadata = pd, gene_metadata = fData)

## preprocess
monocle.object = preprocess_cds(monocle.object, num_dim = 50, norm_method = "none")
### if using integrated data:
# norm_method = "none", alignment_group = "~ experiment"

## plot jack straw plot
#plot_pc_variance_explained(monocle.object)

#monocle.object = reduce_dimension(monocle.object, reduction_method = "UMAP", preprocess_method = "PCA", umap.metric = "euclidean", umap.n_neighbors = 50, umap.min_dist = 0.5, verbose = FALSE)

#plot_cells(monocle.object, color_cells_by="experiment")

## graph learning

## add UMAP from Seurat
monocle.object@int_colData@listData$reducedDims@listData[["UMAP"]] <- seurat.object@reductions[["DIM_UMAP"]]@cell.embeddings
## if you want the old UMAP from the original all cells one, use: "DIM_UMAP"

## cluster
## this is essential to run the learn_graph function later on
monocle.object = cluster_cells(monocle.object)

## plot initial clustering by monocle
#plot_cells(monocle.object, color_cells_by="cluster", group_cells_by="partition", x = 2, y = 1)

## map pseudotime
monocle.object = learn_graph(monocle.object, learn_graph_control=list(ncenter=250, minimal_branch_len = 30), use_partition = FALSE)
# learn_graph_control=list(ncenter=500) - play with this parameter - lower tends to give fewer branches and higher tends to give more
# 500 - old analysis
# 250 - new analysis 

## Plot cells
plot_cells(monocle.object, color_cells_by="partition", group_cells_by="partition", x = 2, y = 1)
```

Define identities of cells 

male
```{r}
monocle.object_male <- choose_graph_segments(monocle.object)
```
female
```{r}
monocle.object_female <- choose_graph_segments(monocle.object)
```
bipotential
```{r}
monocle.object_bipot <- choose_graph_segments(monocle.object)
```
asexual
```{r}
monocle.object_asex <- choose_graph_segments(monocle.object)
```
asexual fate
```{r}
monocle.object_asex_fate <- choose_graph_segments(monocle.object)
```
check
```{r}
df_freq <- data.frame(table(c(colnames(monocle.object_male), colnames(monocle.object_female), colnames(monocle.object_bipot), colnames(monocle.object_asex), colnames(monocle.object_asex_fate))))
paste("number of cells in seurat object is", length(colnames(monocle.object)), ". The number of cells selected here with an identitity is", dim(df_freq)[1])
df_freq <- df_freq[df_freq$Freq > 1, ]
df_freq
```
Inspect where these missing cells are:
```{r}
'%ni%' <- Negate('%in%')

not_assigned_cells <- colnames(monocle.object)[colnames(monocle.object) %ni% c(colnames(monocle.object_male), colnames(monocle.object_female), colnames(monocle.object_bipot), colnames(monocle.object_asex), colnames(monocle.object_asex_fate))]

DimPlot(seurat.object, repel = TRUE, label.size = 5, pt.size = 0.5, cells.highlight = not_assigned_cells, dims = c(2,1), reduction = "DIM_UMAP") +
  coord_fixed() + 
  scale_color_manual(values=c("#000000", "#f54e1e"))
```

```{r}
## create annotation dataframe from these results:
df_monocle_sexes <- rbind(data.frame("cell_name" = colnames(monocle.object_male), "sex" = rep("Male", length(colnames(monocle.object_male)))),
                          data.frame("cell_name" = colnames(monocle.object_female), "sex" = rep("Female", length(colnames(monocle.object_female)))),
                          data.frame("cell_name" = colnames(monocle.object_bipot), "sex" = rep("Bipotential", length(colnames(monocle.object_bipot)))),
                          data.frame("cell_name" = colnames(monocle.object_asex), "sex" = rep("Asexual", length(colnames(monocle.object_asex)))),
                          data.frame("cell_name" = colnames(monocle.object_asex_fate), "sex" = rep("Asexual_Fate", length(colnames(monocle.object_asex_fate)))),
                          data.frame("cell_name" = not_assigned_cells, "sex" = rep("Unassigned", length(not_assigned_cells)))
                          )

dim(df_monocle_sexes)

## order like the metadata
df_monocle_sexes <- df_monocle_sexes[match(rownames(monocle.object@colData), df_monocle_sexes$cell_name), ]

## add this back into the monocle object
monocle.object@colData$Sexes_monocle <- df_monocle_sexes$sex
```

#### Pseudotime Calculation
```{r}
## Order the cells and calculate pseudotime
monocle.object = order_cells(monocle.object)

## Plot
umap_pt <- plot_cells(monocle.object, color_cells_by = "pseudotime", label_cell_groups=FALSE, cell_size = 1, x = 2, y = 1, label_branch_points=FALSE, label_leaves=FALSE, label_groups_by_cluster=FALSE, label_roots = FALSE) +
  coord_fixed() +
  theme_void() +
  labs(title = "Pseudotime") +
  theme(plot.title = element_text(hjust = 0.5))

## view
umap_pt
```
save
```{r}
ggsave("../images_to_export/GCSKO_sexbranch_umap_pt.png", plot = umap_pt, device = "png", path = NULL, scale = 1, width = 10, height = 10, units = "cm", dpi = 300, limitsize = TRUE)
```

Just check if the 'hook' on the males is a lineage or dead/dying/activated gams, or mutants

```{r}
FeaturePlot(tenx.mutant.integrated.sex, features = "PBANKA-0416100", coord.fixed = TRUE, min.cutoff = "q1", dims = c(2,1), reduction = "DIM_UMAP", pt.size = 1, order = TRUE) + 
            theme_void() + 
            labs(title = paste("MG1 (Male)")) + 
            theme(plot.title = element_text(hjust = 0.5, family="Arial", size = 20, face = "bold")) + 
            scale_colour_gradientn(colours=c("#DCDCDC", plasma(30)))
```

It appears MG1 marker expression is decreasing/off in these cells - inspect mutant status

```{r, fig.width = 4, fig.height = 4}
plot <- DimPlot(tenx.mutant.integrated.sex, label = FALSE, label.size = 8, repel = FALSE, pt.size = 0.05, dims = c(2,1), reduction = "DIM_UMAP", group.by = "identity_updated") + 
  coord_fixed() +
  theme(legend.position="bottom", 
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()) + 
  guides(colour=guide_legend(nrow = 3, byrow = TRUE, override.aes = list(size=5)))

HoverLocator(plot = plot, information = FetchData(tenx.mutant.integrated.sex, vars = c("ident", "identity_updated", "nFeature_RNA")))
```

#### Check how well it correlates with the original pseudotime

when pseudotime was calculated on the whole object

```{r}
library(ggpubr)
## extract pseudotime values:
pt_values_new <- as.data.frame(pseudotime(monocle.object, reduction_method = "UMAP"))
pt_values_new$cell_name <- rownames(pt_values_new)
meta_data_df <- as.data.frame(monocle.object@colData)
meta_data_df$cell_name <- rownames(meta_data_df)
meta_data_df <- merge(meta_data_df, pt_values_new, by = "cell_name")
names(meta_data_df)[ncol(meta_data_df)]<- "pt"

ggplot(meta_data_df, aes(x = old_pt_values, y = pt, colour = cluster_colours_figure)) + 
  geom_point() +  
  geom_smooth(method = "lm", se = FALSE) +
  theme_classic() + stat_cor(method = "pearson")
```

This shows very good correlation.

#### Isolate Branches

```{r}
## access the closest principal graph node vertex for each cell and assign it as a column in your colData table using
#colData(monocle.object)$closest_vertex <- monocle.object@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex[,1]

## plot
#plot_cells(monocle.object, color_cells_by = "closest_vertex", label_cell_groups = FALSE)
```

#### Module Construction
```{r}
## find genes that change as a function of pt:
monocle.object_pr_test_res <- graph_test(monocle.object, neighbor_graph="principal_graph", cores=8)

## find significant genes
## I used 0.05 previously in all cells 
## 2884 w. p = 0.01, 3260 w. p = 0.05
pr_deg_ids <- row.names(subset(monocle.object_pr_test_res, q_value < 0.05))

## collect into modules
gene_module_df_sex <- find_gene_modules(monocle.object[pr_deg_ids,], resolution=c(10^seq(-6,2)), random_seed = 1234)

## how many genes in modules?
dim(gene_module_df_sex)
```

```{r, echo = FALSE}
paste("there are", length(levels(gene_module_df_sex$module)), "modules")
```

## Plot Modules

#### General Module Composition

Make a dataframe to plot by aggregating clusters vs. modules
```{r}
## make cell group df
cell_group_df <- tibble::tibble(cell=row.names(colData(monocle.object)), cell_group=colData(monocle.object)$seurat_clusters)

## make plotting df
agg_mat <- aggregate_gene_expression(monocle.object, gene_module_df_sex, cell_group_df)
```

Find out how many genes there are per total so we can add this to the plot
```{r}
## how many genes per module?
genes_per_module <- as.data.frame(table(gene_module_df_sex$module))
genes_per_module
```

Find out which modules our mutant genes reside in
```{r}
## create a list of our mutant gene IDs
list_of_mutant_genes <- c("PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")

## make a dataframe to convert the gene IDs into actual IDs
df_mutant_ids <- as.data.frame(unique(cbind(tenx.mutant.integrated@meta.data$identity_gene_updated, tenx.mutant.integrated@meta.data$identity_updated, tenx.mutant.integrated@meta.data$identity_name_updated)))[-c(1, 3),]
# remove the "820" bit on 10
df_mutant_ids$V1 <- gsub("_820", "", df_mutant_ids$V1)
# change the underscore (_) to a dash (-) in gene IDs
df_mutant_ids$V1 <- gsub("_", "-", df_mutant_ids$V1)
names(df_mutant_ids) <- c("gene_ID", "mutant_identity", "mutant_identity_2")

## subset modules df to include only mutant gene IDs
df_mutant_gene_modules <- as.data.frame(gene_module_df_sex[which(gene_module_df_sex$id %in% list_of_mutant_genes),])
names(df_mutant_gene_modules)[1] <- "gene_ID"

## merge dataframes
df_mutant_gene_modules <- merge(df_mutant_gene_modules, df_mutant_ids, by = "gene_ID")

## Inspect
df_mutant_gene_modules
```

so modules of interest are:
```{r}
table(df_mutant_gene_modules$module)
```

Which modules do other genes of interest lie in?:
```{r}
## landmark genes (genes of interest)
# AP2G - PBANKA-1437500
# AP2 - PBANKA-0909600 - from poran paper
# AP2G-2 - PBANKA-1034300 
# ccp2 - "PBANKA-1319500" - female 820
# p25 - "PBANKA-0515000" - female
# p28 - "PBANKA-0514900" - female
# ccp3 - "PBANKA-1035200" - female -  https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5909122/
# nek4 - "PBANKA-0616700" - female
# ap2-fg - "PBANKA-1415700" - female 
# dozi - "PBANKA-1217700" - female
# MG1 - "PBANKA-0416100" - male 820
# hap2 - "PBANKA-1212600" - male
# MAPK2 - "PBANKA-0933700" - male
# nek1 - "PBANKA-1443000" - male
# cdpk4 - "PBANKA-0615200" - male

## create a list of landmark genes
list_of_landmark_genes <- c("PBANKA-1437500",
                            "PBANKA-0909600",
                            "PBANKA-1034300", 
                            "PBANKA-1319500", 
                            "PBANKA-0515000",
                            "PBANKA-0514900",
                            "PBANKA-1035200",
                            "PBANKA-0616700",
                            "PBANKA-1415700",
                            "PBANKA-1217700",
                            "PBANKA-0416100", 
                            "PBANKA-1212600",
                            "PBANKA-0933700",
                            "PBANKA-1443000",
                            "PBANKA-0615200")

name_of_landmark_genes <- c("AP2-G", 
                            "AP2_poran", 
                            "AP2-G2", 
                            "ccp2", 
                            "p25", 
                            "p28",
                            "ccp3",
                            "nek4",
                            "ap2-fg",
                            "DOZI",
                            "mg1", 
                            "hap2", 
                            "mapk2",
                            "nek1",
                            "cdpk4")

## make a df
name_of_landmark_genes <- data.frame("gene_name" = name_of_landmark_genes, "id" = list_of_landmark_genes)

## make dataframe
df_landmark_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% list_of_landmark_genes),]

## merge dataframes
df_landmark_gene_modules <- merge(df_landmark_gene_modules, name_of_landmark_genes, by = "id")

## inspect
df_landmark_gene_modules
```

enrichment of screen hits in modules
```{r}
## read in screen hits
library("readxl")
screen_hits <- read_excel("../data/Screen/Modules_Clusters_Phenotypes.xlsx")

## get only hits
screen_hits_selected <- screen_hits[which(screen_hits$`Gam phenotype screen` == "Both" | screen_hits$`Gam phenotype screen` == "Females" | screen_hits$`Gam phenotype screen` == "Males"), ] 

## extract gene IDs
gene_hits <- screen_hits_selected$`new gene ID`
## change the underscore to a dash
gene_hits <- gsub("_", "-", gene_hits)

## find out which modules they are in
df_hits_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% gene_hits),]
print("screen hits by module")
table(df_hits_gene_modules$module)

## get the number genes screened in that module
screen_hits_screened <- screen_hits[which(screen_hits$`Gam phenotype screen` == "Both" | screen_hits$`Gam phenotype screen` == "Females" | screen_hits$`Gam phenotype screen` == "Males" | screen_hits$`Gam phenotype screen` == "None" | screen_hits$`Gam phenotype screen` == "male not enough power"), ] 
## extract gene IDs
genes_screened <- screen_hits_screened$`new gene ID`
## change the underscore to a dash
genes_screened <- gsub("_", "-", genes_screened)
## find out which modules they are in
df_screened_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% genes_screened),]
print("total genes screened in this module")
table(df_screened_gene_modules$module)

## make a table with this info
pc_screened <- data.frame(hits = table(df_hits_gene_modules$module), screened =  table(df_screened_gene_modules$module))[,-3]
names(pc_screened) <- c("module", "hits", "screened")
pc_screened$pc <- (pc_screened$hits /pc_screened$screened)*100

## view
pc_screened
```
Further investigation of screen hits
```{r}
## rename df
df_screen_hits_selected <- as.data.frame(screen_hits_selected)
df_screen_hits_selected$'new gene ID' <- gsub("_", "-", df_screen_hits_selected$'new gene ID')
names(df_screen_hits_selected)[2] <- "id"
df_gene_module_df_sex <- as.data.frame(gene_module_df_sex)

## merge dfs together
screen_hits_modules <- merge(df_screen_hits_selected, df_gene_module_df_sex, by = "id")

## view
screen_hits_modules
```

DOZI-regulated genes

Find out how many of the genes in each module has a DOZI-regulated gene

```{r}
DOZI_regulated_genes <-
read.csv(file = "../data/Reference/DOZI_regulated_genes.csv", header = TRUE)

## extract gene IDs
dozi_genes <- DOZI_regulated_genes[DOZI_regulated_genes$DOZI_regulated. == "YES", ]$Gene_ID_PB
## change the underscore to a dash
dozi_genes <- gsub("_", "-", dozi_genes)

## find out which modules they are in
df_dozi_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% dozi_genes),]
print("dozi genes by module")
table(df_dozi_gene_modules$module)
```

#### Visualise module expression

plot out modules
```{r, fig.height = 7, fig.width = 7}
## make aggregated df again so you can edit it
agg_mat <- aggregate_gene_expression(monocle.object, gene_module_df_sex, cell_group_df)

## h clust the aggregated matrix
module_dendro <- hclust(dist(agg_mat))

## use these clusters to reorder the modules
gene_module_df_sex$module <- factor(gene_module_df_sex$module, levels = row.names(agg_mat)[module_dendro$order])

## plot
UMAP_modules <- plot_cells(monocle.object, genes=gene_module_df_sex %>% filter(module %in% c(1:20)),
           cell_size = 2, 
           x = 2, y = 1,
           label_cell_groups=FALSE,
           scale_to_range = TRUE,
           show_trajectory_graph=FALSE) +
                          scale_colour_viridis_c(name = "expression", option = "C", alpha = 1) +
                          coord_fixed() +
                          theme_void() +
                          theme(legend.position = "bottom", strip.text.x = element_text(size = 15))

## view
UMAP_modules
```
save
```{r}
ggsave("../images_to_export/GCSKO_sexbranch_umap_modules.png", plot = UMAP_modules, device = "png", path = NULL, scale = 1, width = 30, height = 30, units = "cm", dpi = 300, limitsize = TRUE)
```

```{r}
## make a dataframe of genes per module
genes_per_module <- as.data.frame(table(gene_module_df_sex$module))

## inspect
genes_per_module
```

```{r, fig.height = 8, fig.width = 12}
## A. Preparation of dataframe

## prepare custom dataframe for all cells by modules:
agg_mat_no_group <- aggregate_gene_expression(monocle.object, gene_module_df_sex, scale_agg_values = TRUE)

## B. annotations

## make an anotation
## add pt to the monocle object
monocle.object@colData$pt <- as.data.frame(pseudotime(monocle.object, reduction_method = "UMAP"))
## make an annotation dataframe
anno_no_group <- data.frame(monocle.object@colData$cluster_colours_figure, monocle.object@colData$pt, as.factor(monocle.object@colData$Prediction.Spearman._Kasia), row.names = rownames(monocle.object@colData))
names(anno_no_group) <- c("Sex", "Pseudotime", "Real_time_prediction")

## make annotation colours
annotation_colours <- list(Sex = c(Male="#016c00", Female="#a52b1e", Bipotential = "#ffe400", Asexual = "#0052c5"),
                           Pseudotime = plasma(12, direction = 1),
                           Real_time_prediction = c("0" = viridis(8, direction = 1)[1] ,"1" =  viridis(8, direction = 1)[2] ,"4" = viridis(8, direction = 1)[3] ,"6" = viridis(8, direction = 1)[4] ,"8" = viridis(8, direction = 1)[5]  ,"12"  = viridis(8, direction = 1)[6]  ,"18" = viridis(8, direction = 1)[7]  ,"24" = viridis(8, direction = 1)[8]))

## change the order of the cols (cells) in data frame
col.order <- rownames(anno_no_group[with(anno_no_group, order(Sex, Pseudotime)), ])
agg_mat_no_group <- agg_mat_no_group[,col.order]

## reorder the rows (gene modules) in the data frame so they are in pt order
## define the order visually and using the clusters originally produced
row.order <- c("8", "3","4", "15", "2", "18", "11",
               "7", "1", "13",
               "10", "14", "12", "16", "9",
               "5","6", "17",
               "19", "20")
## reorder using new order
agg_mat_no_group <- agg_mat_no_group[row.order, ]

## for cuts in columns - used later to count number of cells in each cat
df_meta <- as.data.frame(monocle.object@colData)
female_cells <- rownames(df_meta[which(df_meta$cluster_colours_figure == "Female"), ])
male_cells <- rownames(df_meta[which(df_meta$cluster_colours_figure == "Male"), ])
bi_cells <- rownames(df_meta[which(df_meta$cluster_colours_figure == "Bipotential"), ])
asex_cells <- rownames(df_meta[which(df_meta$cluster_colours_figure == "Asexual"), ])
rm(df_meta)

## add module and the number of cells to the row
## change names for row names to include "module " at the begining of them
labels.row <- stringr::str_c("Module ", row.names(agg_mat_no_group))
## reorder frequency so that it is matching our matrix
genes_per_module_ordered <- genes_per_module[match(row.names(agg_mat_no_group), genes_per_module$Var1), ]
## add number of cells to the rownames for the module
for(i in seq_along(genes_per_module_ordered$Freq)){
  labels.row[i] <- stringr::str_c(labels.row[i]," (n = " ,genes_per_module_ordered$Freq[i], ")")
}

## C. Plotting

## plot
heatmap_main <- pheatmap::pheatmap(agg_mat_no_group, 
                   #scale="row",
                   cluster_cols = FALSE,
                   cluster_rows = FALSE,
                   ## others: ward.D2,
                   #clustering_method="complete",
                   show_colnames = FALSE,
                   labels_row = labels.row,
                   fontsize_row = 15,
                   fontsize = 15,
                   gaps_col = c(length(asex_cells), length(c(asex_cells,bi_cells)), length(c(asex_cells,bi_cells,female_cells))),
                   annotation_col = anno_no_group, 
                   annotation_colors = annotation_colours, 
                   cutree_rows = 6)

## view
heatmap_main
```
save
```{r}
ggsave("../images_to_export/GCSKO_sexbranch_heatmap.png", plot = heatmap_main, device = "png", path = NULL, scale = 1, width = 27, height = 20, units = "cm", dpi = 300, limitsize = TRUE)
```

```{r, fig.height = 8, fig.width = 12}
## A. Preparation of dataframe

## prepare custom dataframe for all cells by modules:
agg_mat_no_group <- aggregate_gene_expression(monocle.object, gene_module_df_sex, scale_agg_values = TRUE)

## B. annotations

## make an anotation
## add pt to the monocle object
monocle.object@colData$pt <- as.data.frame(pseudotime(monocle.object, reduction_method = "UMAP"))
## make an annotation dataframe
anno_no_group <- data.frame(monocle.object@colData$Sexes_monocle, monocle.object@colData$cluster_colours_figure, monocle.object@colData$pt, as.factor(monocle.object@colData$Prediction.Spearman._Kasia), row.names = rownames(monocle.object@colData))
## add names to this dataframe
names(anno_no_group) <- c("Sexes_monocle", "Sex", "Pseudotime", "Real_time_prediction")
## make the sexes classification a factor so it can be reordered (explaination here: https://rstudio-pubs-static.s3.amazonaws.com/7433_4537ea5073dc4162950abb715f513469.html)
anno_no_group$Sexes_monocle <- factor(anno_no_group$Sexes_monocle, levels = c("Asexual", "Unassigned", "Asexual_Fate", "Bipotential", "Female", "Male"))

## make annotation colours
annotation_colours <- list(Sexes_monocle = c(Male="#016c00", Female="#a52b1e", Bipotential = "#ffe400", Asexual = "#0052c5", Asexual_Fate = "#77A9D8", Unassigned = "#0052c5"),
                           Sex = c(Male="#016c00", Female="#a52b1e", Bipotential = "#ffe400", Asexual = "#0052c5"),
                           Pseudotime = plasma(12, direction = 1),
                           Real_time_prediction = c("0" = viridis(8, direction = 1)[1] ,"1" =  viridis(8, direction = 1)[2] ,"4" = viridis(8, direction = 1)[3] ,"6" = viridis(8, direction = 1)[4] ,"8" = viridis(8, direction = 1)[5]  ,"12"  = viridis(8, direction = 1)[6]  ,"18" = viridis(8, direction = 1)[7]  ,"24" = viridis(8, direction = 1)[8]))

## change the order of the cols (cells) in data frame
col.order <- rownames(anno_no_group[with(anno_no_group, order(Sexes_monocle, Pseudotime)), ])
agg_mat_no_group <- agg_mat_no_group[,col.order]

## reorder the rows (gene modules) in the data frame so they are in pt order
## define the order visually and using the clusters originally produced
row.order <- c("8", "3","4", "15", "2", "18", "11",
               "7", "1", "13",
               "10", "14", "12", "16", "9",
               "5","6", "17",
               "19", "20")
## reorder using new order
agg_mat_no_group <- agg_mat_no_group[row.order, ]

## for cuts in columns - used later to count number of cells in each cat
df_meta <- as.data.frame(monocle.object@colData)
female_cells <- rownames(df_meta[which(df_meta$Sexes_monocle == "Female"), ])
male_cells <- rownames(df_meta[which(df_meta$Sexes_monocle == "Male"), ])
bi_cells <- rownames(df_meta[which(df_meta$Sexes_monocle == "Bipotential"), ])
asex_cells <- rownames(df_meta[which(df_meta$Sexes_monocle == "Asexual"), ])
asex_fate_cells <- rownames(df_meta[which(df_meta$Sexes_monocle == "Asexual_Fate"), ])
unassigned_cells <- rownames(df_meta[which(df_meta$Sexes_monocle == "Unassigned"), ])
rm(df_meta)

## add module and the number of cells to the row
## change names for row names to include "module " at the begining of them
labels.row <- stringr::str_c("Module ", row.names(agg_mat_no_group))
## reorder frequency so that it is matching our matrix
genes_per_module_ordered <- genes_per_module[match(row.names(agg_mat_no_group), genes_per_module$Var1), ]
## add number of cells to the rownames for the module
for(i in seq_along(genes_per_module_ordered$Freq)){
  labels.row[i] <- stringr::str_c(labels.row[i]," (n = " ,genes_per_module_ordered$Freq[i], ")")
}

## C. Plotting

## plot
heatmap_main <- pheatmap::pheatmap(agg_mat_no_group, 
                   #scale="row",
                   cluster_cols = FALSE,
                   cluster_rows = TRUE,
                   ## others: ward.D2,
                   #clustering_method="complete",
                   show_colnames = FALSE,
                   labels_row = labels.row,
                   fontsize_row = 15,
                   fontsize = 15,
                   gaps_col = c(length(asex_cells), length(c(asex_cells,unassigned_cells)), length(c(asex_cells,unassigned_cells, asex_fate_cells)), length(c(asex_cells,unassigned_cells, asex_fate_cells,bi_cells)), length(c(asex_cells,unassigned_cells, asex_fate_cells,bi_cells, female_cells)), length(c(asex_cells,unassigned_cells, asex_fate_cells,bi_cells, female_cells, male_cells))),
                   annotation_col = anno_no_group, 
                   annotation_colors = annotation_colours, 
                   cutree_rows = 6)

## view
heatmap_main
```





This is for:
```{r}
## repeat of plot above:
## Plot
umap_pt <- plot_cells(monocle.object, color_cells_by = "pseudotime", label_cell_groups=FALSE, cell_size = 1, x = 2, y = 1, label_branch_points=FALSE, label_leaves=FALSE, label_groups_by_cluster=FALSE, label_roots = FALSE) +
  coord_fixed() +
  theme_void() +
  labs(title = "Pseudotime") +
  theme(plot.title = element_text(hjust = 0.5))

## view
umap_pt
```


#### Visualise the expression of select genes over pseudotime

```{r, fig.height = 8, fig.width = 10}
## landmark genes (genes of interest)
# AP2G - PBANKA-1437500
# AP2 - PBANKA-0909600 - from poran paper
# AP2G-2 - PBANKA-1034300 
#list_of_mutant_genes <- c("PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-1144800", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")

## define genes to plot
list_of_genes_of_interest <- c("PBANKA-0102400", "PBANKA-0413400", "PBANKA-0716500", "PBANKA-0828000", "PBANKA-0902300", "PBANKA-1144800", "PBANKA-1302700", "PBANKA-1418100", "PBANKA-1435200", "PBANKA-1447900", "PBANKA-1454800", "PBANKA-1437500", "PBANKA-1319500", "PBANKA-0416100", "PBANKA-1034300")
## add names
names_of_genes_of_interest <- c("GCSKO-2", "GCSKO-10", "GCSKO-19", "GCSKO-3", "GCSKO-13", "GCSKO-28", "GCSKO-oom", "GCSKO-17", "GCSKO-20", "GCSKO-29", "GCSKO-21", "AP2-G", "CCP2", "MG1", "AP2-G2")

##make df for genes of interest
genes_of_interest <- data.frame(gene = list_of_genes_of_interest, group = c(1:length(list_of_genes_of_interest)), name = names_of_genes_of_interest)
## reorder
#genes_of_interest <- genes_of_interest[match(c("AP2-G", "CCP2", "GCSKO-21", "GCSKO-17", "GCSKO-2", "MG1", "GCSKO-20", "GCSKO-3", "GCSKO-oom", "GCSKO-29", "GCSKO-10", "GCSKO-28", "GCSKO-19", "GCSKO-13"), genes_of_interest$name), ]

## prepare custom dataframe for all cells by modules:
agg_mat_genes_of_interest <- aggregate_gene_expression(monocle.object, genes_of_interest[,1:2])

## reorder using new order
agg_mat_genes_of_interest <- agg_mat_genes_of_interest[,col.order]

## plot
heatmap_plot <- pheatmap::pheatmap(agg_mat_genes_of_interest, 
                   #scale="row",
                   cluster_cols = FALSE,
                   cluster_rows = TRUE,
                   clustering_method="ward.D2",
                   show_colnames = FALSE,
                   labels_row = as.character(genes_of_interest[,3]),
                   gaps_col = c(length(asex_cells), length(c(asex_cells,bi_cells)), length(c(asex_cells,bi_cells,female_cells))),
                   #gaps_row = c(1, 6),
                   cutree_rows = 2,
                   ## trying to fix legend issue here
                   #fontsize_row = 10,
                   #fontsize_col = 3,
                   #cellheight=3, 
                   #cellwidth = 3,
                   legend = TRUE,
                   annotation_legend = FALSE,
                   annotation_col = anno_no_group, 
                   annotation_colors = annotation_colours
                   )

heatmap_plot
```

look at some of the "module" genes now too

```{r, fig.height = 8, fig.width = 10}
## landmark genes (genes of interest)
# AP2G - PBANKA-1437500
# AP2 - PBANKA-0909600 - from poran paper
# AP2G-2 - PBANKA-1034300 
#list_of_mutant_genes <- c("PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-1144800", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")

## define genes to plot
list_of_genes_of_interest <- c("PBANKA-1454000", "PBANKA-1354000")
## add names
names_of_genes_of_interest <- c("GyrB", "DBR1")

##make df for genes of interest
genes_of_interest <- data.frame(gene = list_of_genes_of_interest, group = c(1:length(list_of_genes_of_interest)), name = names_of_genes_of_interest)
## reorder
#genes_of_interest <- genes_of_interest[match(c("AP2-G", "CCP2", "GCSKO-21", "GCSKO-17", "GCSKO-2", "MG1", "GCSKO-20", "GCSKO-3", "GCSKO-oom", "GCSKO-29", "GCSKO-10", "GCSKO-28", "GCSKO-19", "GCSKO-13"), genes_of_interest$name), ]

## prepare custom dataframe for all cells by modules:
agg_mat_genes_of_interest <- aggregate_gene_expression(monocle.object, genes_of_interest[,1:2])

## reorder using new order
agg_mat_genes_of_interest <- agg_mat_genes_of_interest[,col.order]

## plot
heatmap_plot <- pheatmap::pheatmap(agg_mat_genes_of_interest, 
                   #scale="row",
                   cluster_cols = FALSE,
                   cluster_rows = TRUE,
                   clustering_method="ward.D2",
                   show_colnames = FALSE,
                   labels_row = as.character(genes_of_interest[,3]),
                   gaps_col = c(length(asex_cells), length(c(asex_cells,bi_cells)), length(c(asex_cells,bi_cells,female_cells))),
                   #gaps_row = c(1, 6),
                   cutree_rows = 2,
                   ## trying to fix legend issue here
                   #fontsize_row = 10,
                   #fontsize_col = 3,
                   #cellheight=3, 
                   #cellwidth = 3,
                   legend = TRUE,
                   annotation_legend = FALSE,
                   annotation_col = anno_no_group, 
                   annotation_colors = annotation_colours
                   )

heatmap_plot
```





















### Plot specific genes of interest

Side plots

construct new dataframes for the cells from mutants for each sex
```{r}
## The original object contains all cells, we just want wild-type so let's subset out gene_module_df and cell_group_df accordingly

## male
## subset out only male and pre determination cells
male_cells <- tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$at_sex == "male"), ]
## take forward only smart-seq2
male_cells <- male_cells[which(male_cells$experiment == "mutants"), ]
## get cell names
male_cells <- rownames(male_cells)
## subset Seurat object to contain cells of interest  
male.seurat.object <- SubsetData(tenx.mutant.integrated.sex, cells = male_cells)
## make new counts and pheno:
data <- as(as.matrix(GetAssayData(male.seurat.object, assay = "RNA", slot = "data")), 'sparseMatrix')
pd <- data.frame(male.seurat.object@meta.data)
## keep only the columns that are relevant
#pData <- pd %>% select(orig.ident, nCount_RNA, nFeature_RNA)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))
## Construct monocle cds
male.monocle.object <- new_cell_data_set(expression_data = data, cell_metadata = pd, gene_metadata = fData)
## preprocess
male.monocle.object = preprocess_cds(male.monocle.object, num_dim = 50, norm_method = "none")  
## make a new dataframe for cell groups - it is crucial to refactor otherwise aggregate_gene_expression thinks it's out of bounds  
#male_cell_group_df <- data.frame(cell=as.character(factor(male_cell_group_df$cell_id)), cell_group=factor(male_cell_group_df$pt_bin))  
## aggregate expression
male_agg_mat <- aggregate_gene_expression(male.monocle.object, gene_module_df_sex, exclude.na = FALSE)

## female
## subset out only male and pre determination cells
female_cells <- tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$at_sex == "female"), ]
## take forward only wild-type
female_cells <- female_cells[which(female_cells$experiment == "mutants"), ]
## get cell names
female_cells <- rownames(female_cells)
## subset our cell group df to keep only these cells
#female_cell_group_df <- female_cell_group_df[which(female_cell_group_df$cell_id %in% female_cells),]
## subset Seurat object to contain cells of interest  
female.seurat.object <- SubsetData(tenx.mutant.integrated.sex, cells = female_cells)
## make new counts and pheno:
data <- as(as.matrix(GetAssayData(female.seurat.object, assay = "RNA", slot = "data")), 'sparseMatrix')
pd <- data.frame(female.seurat.object@meta.data)
## keep only the columns that are relevant
#pData <- pd %>% select(orig.ident, nCount_RNA, nFeature_RNA)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))
## Construct monocle cds
female.monocle.object <- new_cell_data_set(expression_data = data, cell_metadata = pd, gene_metadata = fData)
## preprocess
female.monocle.object = preprocess_cds(female.monocle.object, num_dim = 50, norm_method = "none")  
## make a new dataframe for cell groups - it is crucial to refactor otherwise aggregate_gene_expression thinks it's out of bounds  
#female_cell_group_df <- data.frame(cell=as.character(factor(female_cell_group_df$cell_id)), cell_group=factor(female_cell_group_df$pt_bin))  
## aggregate expression
female_agg_mat <- aggregate_gene_expression(female.monocle.object, gene_module_df_sex, exclude.na = FALSE)
```

male
```{r, fig.height = 8, fig.width = 12}
# male_agg_mat
## reorder using new order
male_agg_mat <- male_agg_mat[row.order, ]

## make an anotation
anno_male <- data.frame(male.monocle.object@colData$at_sex, male.monocle.object@colData$old_pt_values, genotype = male.monocle.object@colData$identity_updated, row.names = rownames(male.monocle.object@colData))
names(anno_male) <- c("sex", "Pseudotime", "genotype")

## make annotation colours
annotation_colours <- list(sex = c(male="#016c00", female="#a52b1e", 'pre-det' = "#0052c5"),
                           Pseudotime = magma(12, direction = 1))

## change the order of the data frame
col.order.male <- rownames(anno_male[with(anno_male, order(genotype, Pseudotime)), ])
male_agg_mat <- male_agg_mat[,col.order.male]

## plot
heatmap_male <- pheatmap::pheatmap(male_agg_mat, 
                   #scale="row",
                   cluster_cols = FALSE,
                   cluster_rows = FALSE,
                   clustering_method="ward.D2",
                   show_colnames = FALSE,
                   legend = FALSE,
                   annotation_legend = TRUE,
                   annotation_col = anno_male, 
                   annotation_colors = annotation_colours, 
                   cutree_rows = 12)

heatmap_male
```

```{r, fig.height = 8, fig.width = 12}
# female_agg_mat
## reorder using new order
female_agg_mat <- female_agg_mat[row.order, ]

## make an anotation
anno_female <- data.frame(female.monocle.object@colData$at_sex, female.monocle.object@colData$old_pt_values, genotype = female.monocle.object@colData$identity_updated, row.names = rownames(female.monocle.object@colData))
names(anno_female) <- c("sex", "Pseudotime", "genotype")

## make annotation colours
annotation_colours <- list(sex = c(male="#016c00", female="#a52b1e", 'pre-det' = "#0052c5"),
                           Pseudotime = magma(12, direction = 1))

## change the order of the data frame
col.order.female <- rownames(anno_female[with(anno_female, order(genotype, Pseudotime)), ])
female_agg_mat <- female_agg_mat[,col.order.female]

## plot
heatmap_female <- pheatmap::pheatmap(female_agg_mat, 
                   #scale="row",
                   cluster_cols = FALSE,
                   cluster_rows = FALSE,
                   clustering_method="ward.D2",
                   show_colnames = FALSE,
                   legend = FALSE,
                   annotation_legend = FALSE,
                   annotation_col = anno_female, 
                   annotation_colors = annotation_colours, 
                   cutree_rows = 12)

heatmap_female

## save a pheatmap: https://stackoverflow.com/questions/43051525/how-to-draw-pheatmap-plot-to-screen-and-also-save-to-file
```

side plots with groups of mutant cells

female
```{r}
## make a new grouping for cells based on their identity
mutant_group_female <- data.frame(cell = rownames(female.monocle.object@colData), cell_group = female.monocle.object@colData$identity_updated)

## aggregate expression
female_agg_mat_grouped <- aggregate_gene_expression(female.monocle.object, gene_module_df_sex, mutant_group_female, exclude.na = FALSE)

## reorder using new order
female_agg_mat_grouped <- female_agg_mat_grouped[row.order, ]

## plot
pheatmap::pheatmap(female_agg_mat_grouped, 
                   #scale="row",
                   cluster_cols = TRUE,
                   cluster_rows = FALSE,
                   clustering_method="ward.D2",
                   show_colnames = TRUE,
                   legend = FALSE,
                   annotation_legend = FALSE,
                   #annotation_col = anno_female, 
                   #annotation_colors = annotation_colours, 
                   cutree_rows = 12)


```

male
```{r}

```

module 12 inspection

```{r, fig.height = 10, fig.width = 12}
## make a df for module 12 genes
module.12.genes <- gene_module_df_sex[gene_module_df_sex$module == 12, ]$id
module.12.genes <- data.frame(id = module.12.genes, group = module.12.genes)

## prepare custom dataframe for all cells by modules:
agg_mat_module_12 <- aggregate_gene_expression(monocle.object, module.12.genes)

## make an anotation
anno_no_group <- data.frame(monocle.object@colData$sex_UMAP, monocle.object@colData$old_pt_values, row.names = rownames(monocle.object@colData))
names(anno_no_group) <- c("sex", "Pseudotime")

## make annotation colours
annotation_colours <- list(sex = c(male="#016c00", female="#a52b1e", 'pre-det' = "#0052c5"),
                           Pseudotime = magma(12, direction = 1))

## change the order of the data frame
col.order <- c(pre_det_ordered_cells, female_ordered_cells, male_ordered_cells)
agg_mat_module_12 <- agg_mat_module_12[,col.order]

## plot
pheatmap::pheatmap(agg_mat_module_12, 
                   #scale="row",
                   cluster_cols = FALSE,
                   clustering_method="ward.D2",
                   show_colnames = FALSE,
                   annotation_col = anno_no_group, 
                   annotation_colors = annotation_colours,
                   fontsize_row = 7,
                   cutree_rows = 12)
```
save plot
```{r}
heatmap_module_12 <- pheatmap::pheatmap(agg_mat_module_12, 
                   #scale="row",
                   cluster_cols = FALSE,
                   clustering_method="ward.D2",
                   show_colnames = FALSE,
                   annotation_col = anno_no_group, 
                   annotation_colors = annotation_colours,
                   fontsize_row = 7,
                   cutree_rows = 12)




```

AP2 Expression

```{r}
## reading table of AP2 genes
ap2_genes_table <- read.delim(file = "~/data/AP2_genes_table.txt", header = TRUE, sep ="\t")

## extract list of genes
ap2_genes_list <- dplyr::pull(ap2_genes_table, Gene.ID)
ap2_genes_list <- gsub("_", "-", ap2_genes_list)

## make a df for genes
ap2_genes_list <- data.frame(id = ap2_genes_list, group = ap2_genes_list)

## prepare custom dataframe for all cells by modules:
agg_mat_ap2s <- aggregate_gene_expression(monocle.object, ap2_genes_list)

## change the order of the data frame
col.order <- c(pre_det_ordered_cells, female_ordered_cells, male_ordered_cells)
agg_mat_ap2s <- agg_mat_ap2s[,col.order]

## plot
pheatmap::pheatmap(agg_mat_ap2s, 
                   #scale="row",
                   cluster_cols = FALSE,
                   clustering_method="complete",
                   show_colnames = FALSE,
                   annotation_col = anno_no_group, 
                   annotation_colors = annotation_colours,
                   fontsize_row = 7,
                   cutree_rows = 3)
```


### Module Analysis 

Read in Kasia's modules:
```{r}
## read in kasia modules:
kasia_clusters <- read.csv(file = "~/data/Modules_Clusters_Phenotypes.csv", header = TRUE)

## change _ to -:
kasia_clusters$new.gene.ID <- gsub("_", "-", kasia_clusters$new.gene.ID)

## filter out genes not in modules gene_module_df_sex:
kasia_clusters_filtered <- kasia_clusters[which(kasia_clusters$new.gene.ID %in% gene_module_df_sex$id), ]

## rename new gene id
names(kasia_clusters_filtered)[2] <- "id"

## merge together
modules_merged_df <- merge(kasia_clusters_filtered, gene_module_df_sex, by = "id")

## look at the enrichment with a dotplot:
dot_plot_df_pc <- (as.data.frame.matrix(prop.table(table(modules_merged_df$Kasia.Cluster, df_meta_data$identity_combined), margin = 2)) * 100)
```









NOT USED
complex heatmap version

```{r}
## make into matrix to plot
col.order <- agg_mat_all_cells_matrix <- as.matrix(agg_mat_all_cells)
```

make annotation
```{r}
## extract pseudotime values:
pt_values <- as.data.frame(pseudotime(monocle.object, reduction_method = "UMAP"))
names(pt_values) <- "monocle_pt_sex_wt"
tenx.mutant.integrated.sex <- AddMetaData(tenx.mutant.integrated.sex, pt_values)

## save pt values
write.csv(pt_values, file = "~/data_to_export/pt_values_sex_only.csv")
```

```{r}
library(circlize)
## make the annotation df
## get meta data from seurat object and then subset rows out that are wt
df_anno <- tenx.mutant.integrated.sex@meta.data[which(rownames(tenx.mutant.integrated.sex@meta.data) %in% colnames(agg_mat_all_cells_matrix)), ]
## get only columns of interest:
df_anno <- df_anno[ ,c("sex", "monocle_pt_sex_wt"), drop = FALSE ]

## order annotation
df_anno <- df_anno[with(df_anno, order(sex, monocle_pt_sex_wt)),]

## order cols in the matrix
agg_mat_all_cells_matrix <- agg_mat_all_cells_matrix[ ,match(colnames(agg_mat_all_cells_matrix), rownames(df_anno))]

## make annotation
heatmap_annotation <- HeatmapAnnotation(df = cluster_anno, 
                                        col = list(sex = c(male="#016c00", female="#a52b1e", `pre-det` = "#0052c5"), monocle_pt_sex_wt = colorRamp2(c(1:70), inferno(70)))
                                        )

heatmap_annotation <- HeatmapAnnotation(sex = df_anno$sex, pt = df_anno$monocle_pt_sex_wt)
```

plot
```{r}
## make heatmap
modules_heatmap <- Heatmap(agg_mat_all_cells_matrix,
        column_order = NULL,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_column_dend = FALSE,
        column_labels = rep("", ncol(agg_mat_all_cells_matrix)),
        #row_order = module_dendro$order,
        clustering_method_columns = "ward.D2",
        bottom_annotation = heatmap_annotation,
        col = colorRampPalette(rev(brewer.pal(n = 7, name =
  "RdYlBu")))(100), 
        heatmap_legend_param = list(direction = "horizontal"))

## print
draw(modules_heatmap, merge_legend = TRUE, heatmap_legend_side = "bottom", 
    annotation_legend_side = "bottom")
```

```{r}
## extract counts from 10x object
matrix_tenx_counts <- as.matrix(GetAssayData(pb_sex_filtered, assay = "RNA"))
#nk.raw.data <- as.matrix(GetAssayData(pb_sex_filtered, slot = "counts")[, WhichCells(pbmc, ident = "NK")])

## check it is the same as the merged object RNA slot

## check it is the same as the monocle object
matrix_tenx_counts_monocle <- as.matrix(as.data.frame((monocle.object@assays)))
```

```{r}
## make heatmap
modules_heatmap <- Heatmap(matrix_tenx_counts,
        column_order = NULL,
        cluster_columns = TRUE,
        cluster_rows = FALSE,
        show_column_dend = FALSE,
        column_labels = rep("", ncol(matrix_tenx_counts)),
        #row_order = module_dendro$order,
        clustering_method_columns = "ward.D2",
        #bottom_annotation = heatmap_annotation,
        col = colorRampPalette(rev(brewer.pal(n = 7, name =
  "RdYlBu")))(100), 
        heatmap_legend_param = list(direction = "horizontal"))

## print
draw(modules_heatmap, merge_legend = TRUE, heatmap_legend_side = "bottom", 
    annotation_legend_side = "bottom")
```

#### plot as a function of pseudotime

Now, we will integrate the branch data we produced using slingshot and the pseudotime values to plot this heatmap. 

Monocle3 has a handy function that allows us to aggregate expression of groups of cells called aggregate_gene_expression. 

The code for this is located here: https://github.com/cole-trapnell-lab/monocle3/blob/1a02274209c765fe7a60f533a31b1da3dacf6785/R/cluster_genes.R 

Define the groups of cells
```{r}
## Split cells into groups of sexes
female_cells <- tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$sex == "female"), ]
male_cells <- tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$sex == "male"), ]
pre_det_cells <- tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$sex == "pre-det"), ]

## inspect range of pt values to determine bin width
hist(female_cells$PT_LineageFemale)
hist(male_cells$PT_LineageMale)
hist(pre_det_cells$PT_LineageFemale)
hist(pre_det_cells$PT_LineageMale)

```

Use a bin width of 2

there will be two objects for the cell_group_df: male branch and female branch. Both will include the pre-det branch

```{r}
## Define male and female branch cells
# male
male_branch_meta_data <- tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$sex == "pre-det" | tenx.mutant.integrated.sex@meta.data$sex == "male"), ]

male_branch_meta_data <- data.frame(cell_id = rownames(male_branch_meta_data), pt = male_branch_meta_data$PT_LineageMale)

male_cell_group_df <- male_branch_meta_data

#female
female_branch_meta_data <- tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$sex == "pre-det" | tenx.mutant.integrated.sex@meta.data$sex == "female"), ]

female_branch_meta_data <- data.frame(cell_id = rownames(female_branch_meta_data), pt = female_branch_meta_data$PT_LineageFemale)

female_cell_group_df <- female_branch_meta_data

## what's the range of values for each pt?

range(female_cell_group_df$pt)
range(male_cell_group_df$pt)
```

```{r}
## make bin widths
# make a new col for annotation
female_cell_group_df$pt_bin <- NA
for(i in seq(2,68,2)){
  female_cell_group_df$pt_bin[which(female_cell_group_df$pt < i & female_cell_group_df$pt >= (i-2))] <- i
}

male_cell_group_df$pt_bin <- NA
for(i in seq(2,68,2)){
  male_cell_group_df$pt_bin[which(male_cell_group_df$pt < i & male_cell_group_df$pt >= (i-2))] <- i
}
# then remove old pt values
male_cell_group_df <- male_cell_group_df[ ,-2]
female_cell_group_df <- female_cell_group_df[ ,-2]
```

```{r}
## The original object contains all cells, we just want wild-type so let's subset out gene_module_df and cell_group_df accordingly

## male
## subset out only male and pre determination cells
male_cells <- tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$sex == "male" | tenx.mutant.integrated.sex@meta.data$sex == "pre-det"), ]
## take forward only wild-type
male_cells <- male_cells[which(male_cells$identity_combined == "WT" | male_cells$identity_combined == "WT_10X"), ]
#male_cells <- male_cells[which(male_cells$identity_combined == "WT_10X"), ]
## get cell names
male_cells <- rownames(male_cells)
## subset our cell group df to keep only these cells
male_cell_group_df <- male_cell_group_df[which(male_cell_group_df$cell_id %in% male_cells),]
## subset Seurat object to contain cells of interest  
male.seurat.object <- SubsetData(tenx.mutant.integrated.sex, cells = male_cells)
## make new counts and pheno:
data <- as(as.matrix(GetAssayData(male.seurat.object, assay = "RNA", slot = "data")), 'sparseMatrix')
pd <- data.frame(male.seurat.object@meta.data)
## keep only the columns that are relevant
#pData <- pd %>% select(orig.ident, nCount_RNA, nFeature_RNA)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))
## Construct monocle cds
male.monocle.object <- new_cell_data_set(expression_data = data, cell_metadata = pd, gene_metadata = fData)
## preprocess
male.monocle.object = preprocess_cds(male.monocle.object, num_dim = 50, norm_method = "none")  
## make a new dataframe for cell groups - it is crucial to refactor otherwise aggregate_gene_expression thinks it's out of bounds  
male_cell_group_df <- data.frame(cell=as.character(factor(male_cell_group_df$cell_id)), cell_group=factor(male_cell_group_df$pt_bin))  
## aggregate expression
male_agg_mat <- aggregate_gene_expression(male.monocle.object, gene_module_df_sex, male_cell_group_df, exclude.na = FALSE)

## female
## subset out only male and pre determination cells
female_cells <- tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$sex == "female" | tenx.mutant.integrated.sex@meta.data$sex == "pre-det"), ]
## take forward only wild-type
female_cells <- female_cells[which(female_cells$identity_combined == "WT" | female_cells$identity_combined == "WT_10X"), ]
#female_cells <- female_cells[which(female_cells$identity_combined == "WT_10X"), ]
## get cell names
female_cells <- rownames(female_cells)
## subset our cell group df to keep only these cells
female_cell_group_df <- female_cell_group_df[which(female_cell_group_df$cell_id %in% female_cells),]
## subset Seurat object to contain cells of interest  
female.seurat.object <- SubsetData(tenx.mutant.integrated.sex, cells = female_cells)
## make new counts and pheno:
data <- as(as.matrix(GetAssayData(female.seurat.object, assay = "RNA", slot = "data")), 'sparseMatrix')
pd <- data.frame(female.seurat.object@meta.data)
## keep only the columns that are relevant
#pData <- pd %>% select(orig.ident, nCount_RNA, nFeature_RNA)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))
## Construct monocle cds
female.monocle.object <- new_cell_data_set(expression_data = data, cell_metadata = pd, gene_metadata = fData)
## preprocess
female.monocle.object = preprocess_cds(female.monocle.object, num_dim = 50, norm_method = "none")  
## make a new dataframe for cell groups - it is crucial to refactor otherwise aggregate_gene_expression thinks it's out of bounds  
female_cell_group_df <- data.frame(cell=as.character(factor(female_cell_group_df$cell_id)), cell_group=factor(female_cell_group_df$pt_bin))  
## aggregate expression
female_agg_mat <- aggregate_gene_expression(female.monocle.object, gene_module_df_sex, female_cell_group_df, exclude.na = FALSE)
```

```{r, fig.height = 7, fig.width = 5}
## use these clusters to reorder the modules
male_agg_mat <- male_agg_mat[match(levels(gene_module_df_sex$module), row.names(male_agg_mat)), ]
female_agg_mat <- female_agg_mat[match(levels(gene_module_df_sex$module), row.names(female_agg_mat)), ]

pheatmap::pheatmap(male_agg_mat, 
                   scale="row",
                   #clustering_method="ward.D2",
                   cluster_rows = FALSE,
                   cluster_cols = FALSE)

pheatmap::pheatmap(male_agg_mat, 
                   scale="column",
                   #clustering_method="ward.D2",
                   cluster_rows = FALSE,
                   cluster_cols = FALSE)

pheatmap::pheatmap(male_agg_mat, 
                   scale="none",
                   #clustering_method="ward.D2",
                   cluster_rows = FALSE,
                   cluster_cols = FALSE)

pheatmap::pheatmap(female_agg_mat, 
                   scale="row",
                   #clustering_method="ward.D2",
                   cluster_rows = FALSE,
                   cluster_cols = FALSE)

pheatmap::pheatmap(female_agg_mat, 
                   scale="column",
                   #clustering_method="ward.D2",
                   cluster_rows = FALSE,
                   cluster_cols = FALSE)

pheatmap::pheatmap(female_agg_mat, 
                   scale="none",
                   #clustering_method="ward.D2",
                   cluster_rows = FALSE,
                   cluster_cols = FALSE)

```

ComplexHeatmap version
```{r, fig.height = 10, fig.width = 12}
## pheatmap calculates Z scores for plotting values
scale_matrix_by_cols <- function (x) 
{
    m = apply(x, 1, mean, na.rm = T)
    s = apply(x, 1, sd, na.rm = T)
    return((x - m)/s)
}

## calculate z score by col
female_agg_mat_scaled <- t(as.matrix(scale_matrix_by_cols(t(female_agg_mat))))
male_agg_mat_scaled <- t(as.matrix(scale_matrix_by_cols(t(male_agg_mat))))
## reorder cols
female_agg_mat_scaled <- female_agg_mat_scaled[match(levels(gene_module_df_sex$module), row.names(female_agg_mat_scaled)), ]
male_agg_mat_scaled <- male_agg_mat_scaled[match(levels(gene_module_df_sex$module), row.names(male_agg_mat_scaled)), ]

## reorder based on clusters
genes_per_module <- genes_per_module[match(levels(gene_module_df_sex$module), row.names(genes_per_module)), ]

## change names for row names to include "module " at the begining of them
row.names(female_agg_mat_scaled) <- stringr::str_c("Module ", row.names(female_agg_mat_scaled))
row.names(male_agg_mat_scaled) <- stringr::str_c("Module ", row.names(male_agg_mat_scaled))

## add number of cells to the rownames for the module
for(i in seq_along(genes_per_module$Freq)){
  row.names(female_agg_mat_scaled)[i] <- stringr::str_c(row.names(female_agg_mat_scaled)[i]," (n = " ,genes_per_module$Freq[i], ")")
}
for(i in seq_along(genes_per_module$Freq)){
  row.names(male_agg_mat_scaled)[i] <- stringr::str_c(row.names(male_agg_mat_scaled)[i]," (n = " ,genes_per_module$Freq[i], ")")
}

## add annotation:
#heatmap_annotation <- HeatmapAnnotation(df = cluster_anno,
#                                         col = list(
# Identity = c(Male="#016c00", Female="#a52b1e", Asexual= "#0052c5", Committed = "#f2eb23")),
#                                         annotation_legend_param = list(Median_Pseudotime_of_Cluster = list(direction = "horizontal"), Identity = list(nrow = 1)))

library(ComplexHeatmap)
library(RColorBrewer)
modules_heatmap_female <- Heatmap(female_agg_mat_scaled,
        column_order = NULL,
        #row_order = row.names(female_agg_mat_scaled)[module_dendro$order],
        #clustering_method_rows = "ward.D2",
        #bottom_annotation = heatmap_annotation,
        col = colorRampPalette(rev(brewer.pal(n = 7, name =
  "RdYlBu")))(100), 
        heatmap_legend_param = list(direction = "horizontal"))

modules_heatmap_male <- Heatmap(male_agg_mat_scaled,
        column_order = NULL,
        #row_order = module_dendro$order,
        #clustering_method_rows = "ward.D2",
        #bottom_annotation = heatmap_annotation,
        col = colorRampPalette(rev(brewer.pal(n = 7, name =
  "RdYlBu")))(100), 
        heatmap_legend_param = list(direction = "horizontal"))

draw(modules_heatmap_female, merge_legend = TRUE, heatmap_legend_side = "bottom", 
    annotation_legend_side = "bottom")
draw(modules_heatmap_male, merge_legend = TRUE, heatmap_legend_side = "bottom", 
    annotation_legend_side = "bottom")

## https://www.biostars.org/p/380544/ 
```

4 bin width 

```{r}
## Define male and female branch cells
# male
male_branch_meta_data <- tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$sex == "pre-det" | tenx.mutant.integrated.sex@meta.data$sex == "male"), ]

male_branch_meta_data <- data.frame(cell_id = rownames(male_branch_meta_data), pt = male_branch_meta_data$PT_LineageMale)

male_cell_group_df <- male_branch_meta_data

#female
female_branch_meta_data <- tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$sex == "pre-det" | tenx.mutant.integrated.sex@meta.data$sex == "female"), ]

female_branch_meta_data <- data.frame(cell_id = rownames(female_branch_meta_data), pt = female_branch_meta_data$PT_LineageFemale)

female_cell_group_df <- female_branch_meta_data

## what's the range of values for each pt?

range(female_cell_group_df$pt)
range(male_cell_group_df$pt)
```


```{r}
## make bin widths
# make a new col for annotation
female_cell_group_df$pt_bin <- NA
for(i in seq(4,68,4)){
  female_cell_group_df$pt_bin[which(female_cell_group_df$pt < i & female_cell_group_df$pt >= (i-4))] <- i
}

male_cell_group_df$pt_bin <- NA
for(i in seq(4,68,4)){
  male_cell_group_df$pt_bin[which(male_cell_group_df$pt < i & male_cell_group_df$pt >= (i-4))] <- i
}
# then remove old pt values
male_cell_group_df <- male_cell_group_df[ ,-2]
female_cell_group_df <- female_cell_group_df[ ,-2]
```

```{r}
## The original object contains all cells, we just want wild-type so let's subset out gene_module_df and cell_group_df accordingly

## male
## subset our cell group df to keep only these cells
male_cell_group_df <- male_cell_group_df[which(male_cell_group_df$cell_id %in% male_cells),]
## make a new dataframe for cell groups - it is crucial to refactor otherwise aggregate_gene_expression thinks it's out of bounds  
male_cell_group_df <- data.frame(cell=as.character(factor(male_cell_group_df$cell_id)), cell_group=factor(male_cell_group_df$pt_bin))  
## aggregate expression
male_agg_mat <- aggregate_gene_expression(male.monocle.object, gene_module_df_sex, male_cell_group_df, exclude.na = FALSE)

## female
## subset out only male and pre determination cells
## subset our cell group df to keep only these cells
female_cell_group_df <- female_cell_group_df[which(female_cell_group_df$cell_id %in% female_cells),]
## make a new dataframe for cell groups - it is crucial to refactor otherwise aggregate_gene_expression thinks it's out of bounds  
female_cell_group_df <- data.frame(cell=as.character(factor(female_cell_group_df$cell_id)), cell_group=factor(female_cell_group_df$pt_bin))  
## aggregate expression
female_agg_mat <- aggregate_gene_expression(female.monocle.object, gene_module_df_sex, female_cell_group_df, exclude.na = FALSE)
```

```{r, fig.height = 7, fig.width = 5}
## use these clusters to reorder the modules
male_agg_mat <- male_agg_mat[match(levels(gene_module_df_sex$module), row.names(male_agg_mat)), ]
female_agg_mat <- female_agg_mat[match(levels(gene_module_df_sex$module), row.names(female_agg_mat)), ]

pheatmap::pheatmap(male_agg_mat, 
                   scale="row",
                   #clustering_method="ward.D2",
                   cluster_rows = FALSE,
                   cluster_cols = FALSE)

pheatmap::pheatmap(female_agg_mat, 
                   scale="row",
                   #clustering_method="ward.D2",
                   cluster_rows = FALSE,
                   cluster_cols = FALSE)

```



#### expression of modules in mutant cells (side panels)

male
```{r}
## make monocle object with mutants
## extract data
mutant_cells_male <- rownames(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$genotype_combined == "Mutant" & tenx.mutant.integrated.sex@meta.data$sex == "male"),])

## make a new Seurat of this
seurat.object <-SubsetData(tenx.mutant.integrated.sex, cells = mutant_cells_male)

## make new counts and pheno:
## the reason we use the integrated and then subsetted is because these cells have been normalised whereas the cells in pb_sex_filtered have not been normalised (well they have but with doublets in them)
data <- as(as.matrix(GetAssayData(seurat.object, assay = "RNA", slot = "data")), 'sparseMatrix')
pd <- data.frame(seurat.object@meta.data)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

## Construct monocle cds
monocle.object.mutants.male <- new_cell_data_set(expression_data = data, cell_metadata = pd, gene_metadata = fData)

## preprocess
monocle.object.mutants.male = preprocess_cds(monocle.object.mutants.male, num_dim = 50, norm_method = "none")
### if using integrated data:
# norm_method = "none", alignment_group = "~ experiment"

## make a cell group dataframe for aggregating expression values:

mutant_cell_group_df <- data.frame(cell = row.names(monocle.object.mutants.male@colData), cell_group = monocle.object.mutants.male@colData$identity_updated)

## aggregate expression
mutant_male_agg_mat <- aggregate_gene_expression(monocle.object.mutants.male, gene_module_df_sex, mutant_cell_group_df)
```

plot
```{r, fig.height = 7, fig.width = 5}
mutant_male_agg_mat <- mutant_male_agg_mat[match(levels(gene_module_df_sex$module), row.names(mutant_male_agg_mat)), ]

pheatmap::pheatmap(mutant_male_agg_mat, 
                   scale="column",
                   #clustering_method="ward.D2",
                   cluster_rows = FALSE,
                   cluster_cols = TRUE) + theme(legend.position = "bottom")
```

```{r, fig.height = 7, fig.width = 5}
mutant_male_agg_mat <- mutant_male_agg_mat[match(levels(gene_module_df_sex$module), row.names(mutant_male_agg_mat)), ]

pheatmap::pheatmap(mutant_male_agg_mat, 
                   scale="column",
                   #clustering_method="ward.D2",
                   cluster_rows = FALSE,
                   cluster_cols = TRUE) + theme(legend.position = "bottom")
```

female
```{r}
## make monocle object with mutants
## extract data
mutant_cells_female <- rownames(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$genotype_combined == "Mutant" & tenx.mutant.integrated.sex@meta.data$sex == "female"),])

## make a new Seurat of this
seurat.object <-SubsetData(tenx.mutant.integrated.sex, cells = mutant_cells_female)

## make new counts and pheno:
## the reason we use the integrated and then subsetted is because these cells have been normalised whereas the cells in pb_sex_filtered have not been normalised (well they have but with doublets in them)
data <- as(as.matrix(GetAssayData(seurat.object, assay = "RNA", slot = "data")), 'sparseMatrix')
pd <- data.frame(seurat.object@meta.data)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

## Construct monocle cds
monocle.object.mutants.female <- new_cell_data_set(expression_data = data, cell_metadata = pd, gene_metadata = fData)

## preprocess
monocle.object.mutants.female = preprocess_cds(monocle.object.mutants.female, num_dim = 50, norm_method = "none")
### if using integrated data:
# norm_method = "none", alignment_group = "~ experiment"

## make a cell group dataframe for aggregating expression values:
mutant_cell_group_df <- data.frame(cell = row.names(monocle.object.mutants.female@colData), cell_group = monocle.object.mutants.female@colData$identity_updated)

## aggregate expression
mutant_female_agg_mat <- aggregate_gene_expression(monocle.object.mutants.female, gene_module_df_sex, mutant_cell_group_df)
```

plot
```{r, fig.height = 7, fig.width = 5}
mutant_female_agg_mat <- mutant_female_agg_mat[match(levels(gene_module_df_sex$module), row.names(mutant_female_agg_mat)), ]

pheatmap::pheatmap(mutant_female_agg_mat, 
                   scale="column",
                   #clustering_method="ward.D2",
                   cluster_rows = FALSE,
                   cluster_cols = FALSE) + theme(legend.position = "bottom")
```

```{r, fig.height = 7, fig.width = 5}
mutant_female_agg_mat <- mutant_female_agg_mat[match(levels(gene_module_df_sex$module), row.names(mutant_female_agg_mat)), ]

pheatmap::pheatmap(mutant_female_agg_mat, 
                   scale="row",
                   #clustering_method="ward.D2",
                   cluster_rows = FALSE,
                   cluster_cols = TRUE) + theme(legend.position = "bottom")
```

#### for particular genes (lower panel)

```{r, fig.height = 2, fig.width = 9}
## landmark genes (genes of interest)
# AP2G - PBANKA-1437500
# AP2 - PBANKA-0909600 - from poran paper
# AP2G-2 - PBANKA-1034300 
list_of_mutant_genes <- c("PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-1144800", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")

list_of_genes_of_interest <- c("PBANKA-1437500", "PBANKA-0909600","PBANKA-1034300", "PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-1144800", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")
##make df for genes of interest
genes_of_interest <- data.frame(gene = list_of_genes_of_interest, group = c(1:length(list_of_genes_of_interest)))

## aggregate expression
## make plotting df
agg_mat_genes_of_interest <- aggregate_gene_expression(monocle.object, genes_of_interest, cell_group_df)

row.names(agg_mat_genes_of_interest) <- genes_of_interest$gene

#row.names(agg_mat_genes_of_interest) <- factor(row.names(agg_mat_genes_of_interest), levels = row.names(agg_mat_genes_of_interest)[module_dendro$order])
agg_mat_genes_of_interest <- agg_mat_genes_of_interest[,match(rownames(cluster_anno), colnames(agg_mat_genes_of_interest))]

pheatmap::pheatmap(agg_mat_genes_of_interest, 
                   scale="row",
                   cluster_cols = FALSE,
                   cluster_rows = FALSE,
                   clustering_method="ward.D2", 
                   annotation_col = cluster_anno, 
                   annotation_colors = annotation_colours)
```

complex heat map

```{r}
## aggregate gene expression
agg_mat_genes_of_interest <- aggregate_gene_expression(monocle.object, genes_of_interest, df_all_cells)

agg_mat_genes_of_interest <- as.matrix(agg_mat_genes_of_interest)

## make heatmap
modules_heatmap <- Heatmap(agg_mat_genes_of_interest,
        column_order = NULL,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_column_dend = FALSE,
        column_labels = rep("", ncol(agg_mat_all_cells_matrix)),
        #row_order = module_dendro$order,
        clustering_method_columns = "ward.D2",
        bottom_annotation = heatmap_annotation,
        col = colorRampPalette(rev(brewer.pal(n = 7, name =
  "RdYlBu")))(100), 
        heatmap_legend_param = list(direction = "horizontal"))

## print
draw(modules_heatmap, merge_legend = TRUE, heatmap_legend_side = "bottom", 
    annotation_legend_side = "bottom")
```

```{r}
## order cols in the matrix
agg_mat_genes_of_interest <- agg_mat_genes_of_interest[ ,match(rownames(df_anno), colnames(agg_mat_genes_of_interest))]

## make heatmap
modules_heatmap <- Heatmap(agg_mat_genes_of_interest,
        column_order = NULL,
        cluster_columns = TRUE,
        cluster_rows = FALSE,
        show_column_dend = FALSE,
        column_labels = rep("", ncol(agg_mat_all_cells_matrix)),
        #row_order = module_dendro$order,
        clustering_method_columns = "ward.D2",
        bottom_annotation = heatmap_annotation,
        col = colorRampPalette(rev(brewer.pal(n = 7, name =
  "RdYlBu")))(100), 
        heatmap_legend_param = list(direction = "horizontal"))

## print
draw(modules_heatmap, merge_legend = TRUE, heatmap_legend_side = "bottom", 
    annotation_legend_side = "bottom")
```

Using Seurat to visualise cells
```{r}
# find markers for every cluster compared to all remaining cells, report only the positive ones
tenx.mutant.integrated.sex.markers <- FindAllMarkers(tenx.mutant.integrated.sex, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
tenx.mutant.integrated.sex.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
```

```{r}
top10 <- tenx.mutant.integrated.sex.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
DoHeatmap(tenx.mutant.integrated.sex, features = top10$gene) + NoLegend()
```

But we also have the old pt values that we can use in the seurat object ie FeaturePlot(tenx.mutant.integrated.sex, reduction = "pca", pt.size = 0.01, features = "old_pt_values")

So let's plot a heatmap where we plot: (x) all cells vs. (y) genes arranged by module that they belong to. 

add an old pt annotation to the top

prepare data:
```{r}
## extracts only 10x cells 
wt_cells <- rownames(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$identity_combined == "WT_10X"),])

## make a new Seurat of this
seurat.object <-SubsetData(tenx.mutant.integrated.sex, cells = wt_cells)
```

```{r}
DoHeatmap(seurat.object, features = top10$gene) + NoLegend()
```




```{r}
## aggregate gene expression
agg_mat_genes_of_interest <- aggregate_gene_expression(monocle.object, genes_of_interest, df_all_cells)

agg_mat_genes_of_interest <- as.matrix(agg_mat_genes_of_interest)

## make heatmap
modules_heatmap <- Heatmap(agg_mat_genes_of_interest,
        column_order = NULL,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_column_dend = FALSE,
        column_labels = rep("", ncol(agg_mat_all_cells_matrix)),
        #row_order = module_dendro$order,
        clustering_method_columns = "ward.D2",
        bottom_annotation = heatmap_annotation,
        col = colorRampPalette(rev(brewer.pal(n = 7, name =
  "RdYlBu")))(100), 
        heatmap_legend_param = list(direction = "horizontal"))

## print
draw(modules_heatmap, merge_legend = TRUE, heatmap_legend_side = "bottom", 
    annotation_legend_side = "bottom")
```

Expression of CCP2 and MG1 by each genotype and each sex

```{r}
# ccp2 - "PBANKA-1319500" - female 820
# MG1 - "PBANKA-0416100" - male 820

## make a custom dataframe:
marker_820_df <- as.data.frame(t(as.data.frame(tenx.mutant.integrated.sex@assays$RNA@data[c("PBANKA-1319500", "PBANKA-0416100"), ], stringsAsFactors=F)))
marker_820_df$cell_id <- row.names(marker_820_df)
sex_id <- data.frame(sex_at = tenx.mutant.integrated.sex@meta.data$at_sex, genotype = tenx.mutant.integrated.sex@meta.data$identity_updated ,cell_id = row.names(tenx.mutant.integrated.sex@meta.data))
marker_820_df <- merge(marker_820_df, sex_id, by = "cell_id")

ggplot(marker_820_df, aes(fill=sex_at, y=`PBANKA-1319500`, x=genotype)) + 
    geom_violin() +
  geom_jitter(shape=16, position=position_jitter(0.2)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))
```

```{r}
#tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$sex == "pre-det" | tenx.mutant.integrated.sex@meta.data$sex == "female"), ]


VlnPlot(tenx.mutant.integrated.sex, group.by = "identity_updated", split.by = "at_sex", features = c("PBANKA-1319500"), split.plot = TRUE)

VlnPlot(tenx.mutant.integrated.sex, group.by = "identity_updated", split.by = "at_sex", features = c("PBANKA-0416100"), split.plot = TRUE)
```

Differential expression

Re-cluster the data so we have very course grain clusters
```{r}
## find new clusters
tenx.mutant.integrated.sex <- FindClusters(tenx.mutant.integrated.sex, resolution = 1, random.seed = 42, algorithm = 2)

## plot the graph
DimPlot(tenx.mutant.integrated.sex, reduction = "umapoptimised_post_repca", label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "integrated_snn_res.1") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))
```

```{r}
VlnPlot(tenx.mutant.integrated.sex, features = c("PT_Female_UMAP", "PT_Male_UMAP"))
```

#### Show representation of genotypes per cluster

prep for dotplot
```{r}
## make a dataframe that is the meta data
df_meta_data <- as.data.frame(tenx.mutant.integrated.sex@meta.data)

## define order for plotting 
my_levels_sex <- c("2", "3", "9", "6", "11", "5", "0", "10", "13", "14", "12", "8", "15", "1", "4", "7")

## redefine order of clusters:
df_meta_data$seurat_clusters <- factor(x = df_meta_data$seurat_clusters, levels = my_levels_sex)

## make a new df of CLUSTER and IDENTITY
dot_plot_df <- as.data.frame.matrix(table(df_meta_data$seurat_clusters, df_meta_data$identity_combined))
dot_plot_df$cluster <- rownames(dot_plot_df)

## calculate percentage of cells for each genotype
dot_plot_df_pc <- (as.data.frame.matrix(prop.table(table(df_meta_data$seurat_clusters, df_meta_data$identity_combined), margin = 2)) * 100)

## make a column for cluster names
dot_plot_df_pc$cluster <- rownames(dot_plot_df_pc)

## melt dataframe for plotting
library(reshape2)
dot_plot_df_pc_melted <- melt(dot_plot_df_pc, variable.name = "cluster")
colnames(dot_plot_df_pc_melted)[2] <- "identity"

## melt the raw number too
dot_plot_df_melted <- melt(dot_plot_df, variable.name = "cluster")
colnames(dot_plot_df_melted)[2] <- "identity"
colnames(dot_plot_df_melted)[3] <- "raw_number"

## merge together
identical(dot_plot_df_melted$cluster, dot_plot_df_pc_melted$cluster)
dot_plot_merged <- cbind(dot_plot_df_melted, dot_plot_df_pc_melted)
dot_plot_merged <- dot_plot_merged[,c(1,2,3,6)]

## redefine order of clusters
dot_plot_merged$cluster <- factor(x = dot_plot_merged$cluster, levels = my_levels_sex)

## where values are zero, add NA
## find wells where it's zero
zero_values <- dot_plot_merged$value == 0
dot_plot_merged$value[zero_values] <- NA

## also do for raw number
zero_values <- dot_plot_merged$raw_number == 0
dot_plot_merged$raw_number[zero_values] <- NA

## reorder x axis:
my_levels_genotype <- c("GCSKO-oom", "GCSKO-29", "GCSKO-2", "GCSKO-19", "GCSKO-3", "GCSKO-21", "GCSKO-13", "GCSKO-28", "GCSKO-10_820", "GCSKO-17", "GCSKO-20", "WT", "WT_10X")

dot_plot_merged$identity <- factor(x = dot_plot_merged$identity, levels = my_levels_genotype)
```

plot
```{r, fig.width = 6, fig.height= 7}
## plot
dot_plot_identity <- ggplot(dot_plot_merged, aes(y = factor(cluster), x = factor(identity))) +
      ## make into a dot plot
      geom_point(aes(colour=value, size=raw_number)) + 
      scale_color_gradient(low="blue", high="red", limits=c( 0, max(dot_plot_df_pc_melted$value)), na.value="white") +
      #change the colours
      scale_colour_viridis(option = "inferno", guide = "colourbar", na.value="white") +
      theme_classic() +
      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), text=element_text(size=16,  family="Arial")) +
      ylab("Cluster") +
      xlab("Identity") +
      theme(axis.text.x=element_text(size=12, angle=45, hjust=1, vjust=1), axis.text.y=element_text(size=12,), legend.position = "bottom", plot.margin = unit(c(1,3,1,3), "lines")) +
    ## annotate males
    geom_hline(aes(yintercept = 2.5)) +
    ## annotate females
    geom_hline(aes(yintercept = 7.5)) +
    ## annotate pheno 1
    geom_vline(aes(xintercept = 4.5)) +
    ## annotate pheno 2
    geom_vline(aes(xintercept = 5.5)) +    
    ## annotate pheno 3
    geom_vline(aes(xintercept = 7.5)) +
    ## annotate pheno 4
    geom_vline(aes(xintercept = 11.5))

## print
print(dot_plot_identity)
```




cut off and plot
```{r}
pre_branch_cells <- c(2,3)
inmature_male_cells <- c()
inmature_female_cells <-
mature_male_cells <- 
mature_female_cells <- 

## plot the graph
DimPlot(tenx.mutant.integrated.sex, reduction = "umapoptimised_post_repca", label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "integrated_snn_res.1") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom")
```



```{r}
wt_cells <- row.names(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$identity_combined == "WT" | tenx.mutant.integrated.sex@meta.data$identity_combined == "WT_10X"), ])

male_inmature_cells <- row.names(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$identity_combined == "WT" | tenx.mutant.integrated.sex@meta.data$identity_combined == "WT_10X"), ])



early_wt_cells <- row.names(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$identity_combined == "WT" && tenx.mutant.integrated.sex@meta.data$PT_LineageFemale < 46), ])

FindMarkers(tenx.mutant.integrated.sex, cells.1 = , cells.2 = )
```

### Generate New Clusters

We must now recalculate the clusters to gain a better understanding of the heterogeneity of the subset. Since using the previous clusters, the asexual cells obscured some of the variation. 

```{r}
## copy old clusters
tenx.mutant.integrated.sex <- AddMetaData(tenx.mutant.integrated.sex, tenx.mutant.integrated.sex@meta.data$seurat_clusters, col.name = "pre_sex_clusters")
```

```{r}
## generate new clusters at various resolutions
tenx.mutant.integrated.sex <- FindNeighbors(tenx.mutant.integrated.sex, dims = 1:15)
tenx.mutant.integrated.sex <- FindClusters(tenx.mutant.integrated.sex, resolution = c(2,3,4,5,6), random.seed = 42, algorithm = 2)
```

### Visualise

#### Choose Cluster Resolution

View the clusters at different resolutions to chose the appropraite resolution
```{r}
## plot
DimPlot(tenx.mutant.integrated.sex, reduction = "umapoptimised_post_repca", label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "integrated_snn_res.2") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))

DimPlot(tenx.mutant.integrated.sex, reduction = "umapoptimised_post_repca", label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "integrated_snn_res.3") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))

DimPlot(tenx.mutant.integrated.sex, reduction = "umapoptimised_post_repca", label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "integrated_snn_res.4") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))

DimPlot(tenx.mutant.integrated.sex, reduction = "umapoptimised_post_repca", label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "integrated_snn_res.5") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))

DimPlot(tenx.mutant.integrated.sex, reduction = "umapoptimised_post_repca", label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5, group.by = "integrated_snn_res.6") +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))
```

Go with 4 clusters
```{r}
tenx.mutant.integrated.sex <- FindClusters(tenx.mutant.integrated.sex, resolution = 4, random.seed = 42, algorithm = 2)

DimPlot(tenx.mutant.integrated.sex, reduction = "umapoptimised_post_repca", label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5) +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))
```

#### Original UMAP

You can also use the original UMAP projection
```{r, fig.height = 7, fig.width = 7}
DimPlot(tenx.mutant.integrated.sex, label = TRUE, repel = TRUE, label.size = 5, pt.size = 0.5) +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(nrow=3,byrow=TRUE, override.aes = list(size=4)))
```

#### Representation

look at cluster representation
```{r, echo = FALSE}
## for loop which takes each cluster and makes a list of cells and then plots a highlighted plot and adds it to a list

## make a df of the number of 
n_per_cluster <- as.data.frame(table(tenx.mutant.integrated.sex@meta.data$seurat_clusters))
rownames(n_per_cluster) <- n_per_cluster$Var1
n_per_cluster <- n_per_cluster[,2]

## make a blank list
list_UMAPs_by_cluster <- vector(mode = "list", length = length(levels(tenx.mutant.integrated.sex@meta.data$seurat_clusters)))

## for loop
for(i in seq_along(levels(tenx.mutant.integrated.sex@meta.data$seurat_clusters))){
  ## make a list of cells
  list_of_cells <- rownames(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$seurat_clusters == levels(tenx.mutant.integrated.sex@meta.data$seurat_clusters)[i]), ])
  umap_plot <- DimPlot(tenx.mutant.integrated.sex, label = FALSE, repel = TRUE, pt.size = 0.1, cells.highlight = list_of_cells, reduction = "umapoptimised_post_repca") + 
  coord_fixed() + 
  scale_color_manual(values=c("#000000", "#f54e1e")) + 
  theme_void() + 
  labs(title = paste("cluster", levels(tenx.mutant.integrated.sex@meta.data$seurat_clusters)[i], "\n", "(n = ", n_per_cluster[i],")")) + 
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none")
  ## add to the list
  list_UMAPs_by_cluster[[i]] <- umap_plot
}
```

plot
```{r}
## this function writes the next bit of code for you
ploty <- c()
for(i in seq_along(levels(tenx.mutant.integrated.sex@meta.data$seurat_clusters))){
  ploty <- paste0(ploty, "list_UMAPs_by_cluster[[", i, "]]", " + ")
}
```

```{r, fig.height = 15, fig.width = 20}
## plot
library(gridExtra)
grid.arrange(list_UMAPs_by_cluster[[1]] , list_UMAPs_by_cluster[[2]] , list_UMAPs_by_cluster[[3]] , list_UMAPs_by_cluster[[4]] , list_UMAPs_by_cluster[[5]] , list_UMAPs_by_cluster[[6]] , list_UMAPs_by_cluster[[7]] , list_UMAPs_by_cluster[[8]] , list_UMAPs_by_cluster[[9]] , list_UMAPs_by_cluster[[10]] , list_UMAPs_by_cluster[[11]] , list_UMAPs_by_cluster[[12]] , list_UMAPs_by_cluster[[13]] , list_UMAPs_by_cluster[[14]] , list_UMAPs_by_cluster[[15]] , list_UMAPs_by_cluster[[16]] , list_UMAPs_by_cluster[[17]] , list_UMAPs_by_cluster[[18]] , list_UMAPs_by_cluster[[19]] , list_UMAPs_by_cluster[[20]] , list_UMAPs_by_cluster[[21]] , list_UMAPs_by_cluster[[22]] , list_UMAPs_by_cluster[[23]] , list_UMAPs_by_cluster[[24]] , list_UMAPs_by_cluster[[25]] , list_UMAPs_by_cluster[[26]] , list_UMAPs_by_cluster[[27]] , list_UMAPs_by_cluster[[28]] , list_UMAPs_by_cluster[[29]] , list_UMAPs_by_cluster[[30]] , list_UMAPs_by_cluster[[31]], ncol = 5)
```


```{r}
## for loop which takes each cluster and makes a list of cells and then plots a highlighted plot and adds it to a list

## make a df of the number of 
n_per_cluster <- as.data.frame(table(tenx.mutant.integrated.sex@meta.data$seurat_clusters))
rownames(n_per_cluster) <- n_per_cluster$Var1
n_per_cluster <- n_per_cluster[,2]

## make a blank list
list_UMAPs_by_cluster <- vector(mode = "list", length = length(levels(tenx.mutant.integrated.sex@meta.data$seurat_clusters)))

## for loop
for(i in seq_along(levels(tenx.mutant.integrated.sex@meta.data$seurat_clusters))){
  ## make a list of cells
  list_of_cells <- rownames(tenx.mutant.integrated.sex@meta.data[which(tenx.mutant.integrated.sex@meta.data$seurat_clusters == levels(tenx.mutant.integrated.sex@meta.data$seurat_clusters)[i]), ])
  umap_plot <- DimPlot(tenx.mutant.integrated.sex,  reduction = "umap", label = FALSE, repel = TRUE, pt.size = 0.1, cells.highlight = list_of_cells) + 
  coord_fixed() + 
  scale_color_manual(values=c("#000000", "#f54e1e")) + 
  theme_void() + 
  labs(title = paste("cluster", levels(tenx.mutant.integrated.sex@meta.data$seurat_clusters)[i], "\n", "(n = ", n_per_cluster[i],")")) + 
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none")
  ## add to the list
  list_UMAPs_by_cluster[[i]] <- umap_plot
}
```

```{r, fig.height = 15, fig.width = 20}
## plot
grid.arrange(list_UMAPs_by_cluster[[1]] , list_UMAPs_by_cluster[[2]] , list_UMAPs_by_cluster[[3]] , list_UMAPs_by_cluster[[4]] , list_UMAPs_by_cluster[[5]] , list_UMAPs_by_cluster[[6]] , list_UMAPs_by_cluster[[7]] , list_UMAPs_by_cluster[[8]] , list_UMAPs_by_cluster[[9]] , list_UMAPs_by_cluster[[10]] , list_UMAPs_by_cluster[[11]] , list_UMAPs_by_cluster[[12]] , list_UMAPs_by_cluster[[13]] , list_UMAPs_by_cluster[[14]] , list_UMAPs_by_cluster[[15]] , list_UMAPs_by_cluster[[16]] , list_UMAPs_by_cluster[[17]] , list_UMAPs_by_cluster[[18]] , list_UMAPs_by_cluster[[19]] , list_UMAPs_by_cluster[[20]] , list_UMAPs_by_cluster[[21]] , list_UMAPs_by_cluster[[22]] , list_UMAPs_by_cluster[[23]] , list_UMAPs_by_cluster[[24]] , list_UMAPs_by_cluster[[25]] , list_UMAPs_by_cluster[[26]] , list_UMAPs_by_cluster[[27]] , list_UMAPs_by_cluster[[28]] , list_UMAPs_by_cluster[[29]] , list_UMAPs_by_cluster[[30]] , list_UMAPs_by_cluster[[31]], ncol = 5)
```

#### Show correspondance with old clusters (Alluvium plot, Sankey diagram)

```{r}
##This is the set up for this:
## two clusters that differ
table(tenx.mutant.integrated.sex@meta.data$seurat_clusters, tenx.mutant.integrated.sex@meta.data$pre_sex_clusters)
```

```{r}
## hemberg uses gvisSankey in https://github.com/hemberg-lab/scmap/blob/3aa2bb487a80a946469393857cea6a6effc618fb/R/Utils.R code - so maybe update with this?

## make a dataframe that is the meta data
df_meta_data <- as.data.frame(tenx.mutant.integrated.sex@meta.data)

df_alluvial <- melt(table(data.frame(full_clusters = df_meta_data$pre_sex_clusters, sex_clusters = df_meta_data$seurat_clusters)))

## load required package
#library(ggalluvial)

## plot
ggplot(df_alluvial, aes(y = value, axis1 = full_clusters, axis2 = sex_clusters)) +
  geom_alluvium(aes(fill = sex_clusters),
                width = 0, knot.pos = 0, reverse = FALSE) +
  guides(fill = FALSE) +
  geom_stratum(width = 1/8, reverse = FALSE) +
  geom_text(stat = "stratum", infer.label = TRUE, reverse = FALSE) +
  scale_x_continuous(breaks = 1:2, labels = c("original cluster", "Sex Cluster")) +
  coord_flip() +
  ggtitle("Cluster Identiity in full dataset vs. sex only") +
    theme_classic()
```

#### Show representation of genotypes per cluster

prep for dotplot
```{r}
## make a dataframe that is the meta data
df_meta_data <- as.data.frame(tenx.mutant.integrated.sex@meta.data)

## define order for plotting 
my_levels_sex <- c("0", "9", "28", "2", "29", "16", "22", "23", "15", "21", "30", "4", "3", "18", "7", "8", "6", "20", "12", "26", "13", "5", "11", "25", "1", "17", "10", "24", "14", "27", "19")

## redefine order of clusters:
df_meta_data$seurat_clusters <- factor(x = df_meta_data$seurat_clusters, levels = my_levels_sex)

## make a new df of CLUSTER and IDENTITY
dot_plot_df <- as.data.frame.matrix(table(df_meta_data$seurat_clusters, df_meta_data$identity_combined))
dot_plot_df$cluster <- rownames(dot_plot_df)

## calculate percentage of cells for each genotype
dot_plot_df_pc <- (as.data.frame.matrix(prop.table(table(df_meta_data$seurat_clusters, df_meta_data$identity_combined), margin = 2)) * 100)

## make a column for cluster names
dot_plot_df_pc$cluster <- rownames(dot_plot_df_pc)

## melt dataframe for plotting
library(reshape2)
dot_plot_df_pc_melted <- melt(dot_plot_df_pc, variable.name = "cluster")
colnames(dot_plot_df_pc_melted)[2] <- "identity"

## melt the raw number too
dot_plot_df_melted <- melt(dot_plot_df, variable.name = "cluster")
colnames(dot_plot_df_melted)[2] <- "identity"
colnames(dot_plot_df_melted)[3] <- "raw_number"

## merge together
identical(dot_plot_df_melted$cluster, dot_plot_df_pc_melted$cluster)
dot_plot_merged <- cbind(dot_plot_df_melted, dot_plot_df_pc_melted)
dot_plot_merged <- dot_plot_merged[,c(1,2,3,6)]

## redefine order of clusters
dot_plot_merged$cluster <- factor(x = dot_plot_merged$cluster, levels = my_levels_sex)

## where values are zero, add NA
## find wells where it's zero
zero_values <- dot_plot_merged$value == 0
dot_plot_merged$value[zero_values] <- NA

## also do for raw number
zero_values <- dot_plot_merged$raw_number == 0
dot_plot_merged$raw_number[zero_values] <- NA

## reorder x axis:
my_levels_genotype <- c("GCSKO-oom", "GCSKO-29", "GCSKO-2", "GCSKO-19", "GCSKO-3", "GCSKO-21", "GCSKO-13", "GCSKO-28", "GCSKO-10_820", "GCSKO-17", "GCSKO-20", "WT", "WT_10X")

dot_plot_merged$identity <- factor(x = dot_plot_merged$identity, levels = my_levels_genotype)
```

plot
```{r, fig.width = 6, fig.height= 7}
## plot
dot_plot_identity <- ggplot(dot_plot_merged, aes(y = factor(cluster), x = factor(identity))) +
      ## make into a dot plot
      geom_point(aes(colour=value, size=raw_number)) + 
      scale_color_gradient(low="blue", high="red", limits=c( 0, max(dot_plot_df_pc_melted$value)), na.value="white") +
      #change the colours
      scale_colour_viridis(option = "inferno", guide = "colourbar", na.value="white") +
      theme_classic() +
      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), text=element_text(size=16,  family="Arial")) +
      ylab("Cluster") +
      xlab("Identity") +
      theme(axis.text.x=element_text(size=12, angle=45, hjust=1, vjust=1), axis.text.y=element_text(size=12,), legend.position = "bottom", plot.margin = unit(c(1,3,1,3), "lines")) +
    ## annotate males
    geom_hline(aes(yintercept = 5.5)) +
    ## annotate females
    geom_hline(aes(yintercept = 20.5)) +
    ## annotate pheno 1
    geom_vline(aes(xintercept = 4.5)) +
    ## annotate pheno 2
    geom_vline(aes(xintercept = 5.5)) +    
    ## annotate pheno 3
    geom_vline(aes(xintercept = 7.5)) +
    ## annotate pheno 4
    geom_vline(aes(xintercept = 11.5))

## print
print(dot_plot_identity)
```
























# Save and Export {.tabset}

save environment
```{r}
## This saves everything in the global environment for easy recall later
#save.image(file = "GCSKO_Sex_Branch_Analysis.RData")
#load(file = "GCSKO_Sex_Branch_Analysis.RData")
```

save modules
```{r}
#gene_module_df_sex
write.csv(gene_module_df_sex, file = "../data_to_export/gene_module_df_sex.csv")
#save(pb_30k_sex_filtered, pb_sex_filtered, file = "Part_2_input.Rdata")
```

Save object(s)
```{r}
## save integrated object to file
#saveRDS(tenx.mutant.integrated.sex, file = "../data_to_export/tenx.mutant.integrated.sex.processed.RDS") 
## restore the object
#tenx.mutant.integrated <- readRDS("../data_to_export/tenx.mutant.integrated.sex.processed.RDS")
```

# Appendix {.tabset}

### Useful info

```{r}
## The tree for monocle is located here:
# monocle.object@principal_graph_aux[["UMAP"]]$dp_mst 
## see more info below in getAnywhere(learn_graph)
## in order to get a plottable dataframe of this:
#test <- as.data.frame(t(as.data.frame(monocle.object@principal_graph_aux[["UMAP"]]$dp_mst)))
#ggplot(test, aes(x = DIMUMAP_1, y = DIMUMAP_2)) + geom_point()

## the curves for slingshot are located here:
#as.data.frame(crv1@curves$curve1$s)
## so a plot can be made by:
#ggplot(as.data.frame(crv1@curves$curve3$s), aes(x= DIMUMAP_1, y = DIMUMAP_2)) + geom_line()
```


### Functions Info

```{r}
Seurat:::DoHeatmap
```

```{r}
monocle:::plot_pseudotime_heatmap
```

```{r}
## to understand how the line is stored
getAnywhere(learn_graph)
```


```{r}
getAnywhere(aggregate_gene_expression)
```

so essentially it first takes the counts matrix and subsets it by your gene groups, then it sums the values - if you specify scale then it will calculate the z score of the transformed dataframe 







## A. Diffusion Map

construct map
```{r}
## construct diffusion map
## http://www.bioconductor.org/packages/devel/bioc/vignettes/slingshot/inst/doc/vignette.html
## input is a transformed expression matrix (genes as cols and cells as rows)
dm <- DiffusionMap(t(as.data.frame(tenx.mutant.integrated.sex@assays$integrated@data)))

## extract meta data for plotting
df_meta_data <- (as.data.frame(tenx.mutant.integrated.sex@meta.data))

## make combined dataframe
rd2 <- as.data.frame(cbind(DC1 = dm$DC1, DC2 = dm$DC2, identity = as.factor(as.character(tenx.mutant.integrated.sex@meta.data$post_integration_clusters))))

## plot
ggplot(rd2, aes(x = DC1, y = DC2, colour = as.character(identity))) + geom_point(size = 1) + 
  theme(axis.ticks.y = element_blank()) + 
  theme_classic()
```







```{r, fig.width = 10, fig.height = 3}
## make a density plot for real time correlations using kasia data
## make an annotation dataframe
anno_real_time <- data.frame(monocle.object@colData$cluster_colours_figure, monocle.object@colData$pt, monocle.object@colData$Prediction.Spearman._Kasia, row.names = rownames(monocle.object@colData))
names(anno_real_time) <- c("sex", "Pseudotime", "real_time")

## change the order of the cols (cells) in data frame
col.order <- rownames(anno_real_time[with(anno_real_time, order(sex, Pseudotime)), ])
anno_real_time <- anno_real_time[col.order,]

## add an "order" col to the dataframe to assist in plotting
anno_real_time$order <- c(1:nrow(anno_real_time))

#### plot density plot x
dens1 <- ggplot(anno_real_time, aes(x = order, fill = as.factor(real_time))) + 
                geom_density(alpha = 0.2) +
                #theme_void() + 
                #theme(legend.position = "none")
                ## add annotations for sex
      geom_rect(data = cluster_anno, mapping=aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2, fill=Median_Pseudotime_of_Cluster), inherit.aes = FALSE) +
    scale_fill_viridis_c(option = "plasma") +
  ## flip coordinates 
  ## geoms below will use another color scale
    new_scale_fill() +
    geom_rect(data = cluster_anno, mapping=aes(xmin=Bx1, xmax=Bx2, ymin=By1, ymax=By2, fill=Identity), inherit.aes = FALSE) +
    scale_fill_manual(values = c("Male" ="#016c00", "Female"="#a52b1e", "Asexual"= "#0052c5", "Committed" = "#f2eb23"))

dens1

```



### TO PUT BACK IN 

### A. 

Put this in after you have decided what is actually male and female, also add a heatmap version below and figure out expression values (e.g. it's a Z-score at the moment)

```{r, fig.height = 10, fig.width = 10}
    ## subset males and females
## from the merge script:
#male_clusters <- c("22", "18", "9", "16")
#female_clusters <- c("19","24","20","3")

## subset males 
mutant_male_seurat <- subset(mutant_only_seurat, idents = c("22", "18", "9", "16"))

## subset females <- 
mutant_female_seurat <- subset(mutant_only_seurat, idents = c("19","24","20","3"))

   ## mca dataset of core genes

## read in data
df_mca_core_genes <- as.data.frame(read.csv("../data/Reference/mca_core_genes.csv",header = TRUE))

## subset male core genes
mca_male_core_genes <- df_mca_core_genes[which(df_mca_core_genes$Unique_Core == "Male"), ]$feature_symbol
## change underscore to dash
mca_male_core_genes <- gsub("_", "-", mca_male_core_genes)
mca_male_core_genes <- mca_male_core_genes[which(mca_male_core_genes %in% rownames(mutant_male_seurat@assays$RNA@data))]

## subset female core genes
mca_female_core_genes <- df_mca_core_genes[which(df_mca_core_genes$Unique_Core == "Female"), ]$feature_symbol
## change underscore to dash
mca_female_core_genes <- gsub("_", "-", mca_female_core_genes)
mca_female_core_genes <- mca_female_core_genes[which(mca_female_core_genes %in% rownames(mutant_female_seurat@assays$RNA@data))]

    ## plot

# PBANKA-0828000         GCSKO-3  GD1

# PBANKA-1302700       GCSKO-oom  MD1 
# PBANKA-1447900        GCSKO-29  MD2
# PBANKA-0102400         GCSKO-2  MD3 
# PBANKA-0716500        GCSKO-19  MD4 
# PBANKA-0413400    GCSKO-10_820  MD5

# PBANKA-1454800        GCSKO-21  FD1
# PBANKA-0902300        GCSKO-13  FD2
# PBANKA-1418100        GCSKO-17  FD3   
# PBANKA-1435200        GCSKO-20  FD4 

## reorder the levels so you can plot the clusters as you wish
#my_levels_male <- c("GCSKO-3", "GCSKO-2", "GCSKO-19", "GCSKO-10_820", "GCSKO-21", "GCSKO-13", "GCSKO-17", "GCSKO-20")
my_levels_male <- c("gd1", "md3", "md4", "md5", "fd1", "fd2", "fd3", "fd4")
#my_levels_female <- c("GCSKO-21", "GCSKO-13", "GCSKO-17", "GCSKO-20", "GCSKO-oom", "GCSKO-29", "GCSKO-2", "GCSKO-19", "GCSKO-10_820")
my_levels_female <- c("gd1", "fd1", "fd2", "fd3", "fd4", "md1", "md2", "md3", "md4", "md5")

## reorder the levels
mutant_male_seurat@meta.data$identity_name_updated <- factor(x = mutant_male_seurat@meta.data$identity_name_updated, levels = my_levels_male)
#mutant_male_seurat@meta.data$identity_updated <- factor(x = mutant_male_seurat@meta.data$identity_updated, levels = my_levels_male)
mutant_female_seurat@meta.data$identity_name_updated <- factor(x = mutant_female_seurat@meta.data$identity_name_updated, levels = my_levels_female)
#mutant_female_seurat@meta.data$identity_updated <- factor(x = mutant_female_seurat@meta.data$identity_updated, levels = my_levels_female)

## plot male
dot_plot_male <- DotPlot(mutant_male_seurat, assay = "RNA", features = mca_male_core_genes, group.by = "identity_combined") +
  theme_classic() +
  # change appearance and remove axis elements, and make room for arrows
  theme(axis.text.x = element_text(size=16, angle = 45, hjust=1,vjust=1, family = "Arial"), text=element_text(size=16, family="Arial"), legend.position = "bottom", legend.direction = "horizontal", legend.box = "vertical", plot.title = element_blank(), plot.margin = unit(c(1,3,1,3), "lines")) +
  #change the colours
  scale_colour_viridis(option = "inferno", guide = "colourbar", na.value="white", begin = 0, end = 1, direction = 1) +
  ## change x axis label
  labs(x = "MCA Core Genes", y = "Genotype", title = "Expression of Male MCA Core Genes in Male Mutant Cells") +
  ## change label on bottom of plot so we can indicate markers
  #scale_y_discrete(labels = c("gd1", "md3", "md4", "md5", "fd1", "fd2", "fd3", "fd4")) +
  coord_flip()

## view
print(dot_plot_male)


## plot female
dot_plot_female <- DotPlot(mutant_female_seurat, assay = "RNA", features = mca_female_core_genes, group.by = "identity_combined") +
  theme_classic() +
  # change appearance and remove axis elements, and make room for arrows
  theme(axis.text.x = element_text(size=16, angle = 45, hjust=1,vjust=1, family = "Arial"), text=element_text(size=16, family="Arial"), legend.position = "bottom", legend.direction = "horizontal", legend.box = "vertical", plot.title = element_blank(), plot.margin = unit(c(1,3,1,3), "lines")) +
  #change the colours
  scale_colour_viridis(option = "inferno", guide = "colourbar", na.value="white", begin = 0, end = 1, direction = 1) +
  ## change x axis label
  labs(x = "MCA Core Genes", y = "Genotype", title = "Expression of Female MCA Core Genes in Feale Mutant Cells") +
  ## change label on bottom of plot so we can indicate markers
  #scale_y_discrete(labels = c("fd1", "fd2", "fd3", "fd4","md1", "md2",  "md3", "md4", "md5")) +
coord_flip()

## view
print(dot_plot_female)
```

save
```{r}
ggsave("../images_to_export/GCSKO_sexbranch_dot_male.png", plot = dot_plot_male, device = "png", path = NULL, scale = 1, width = 30, height = 60, units = "cm", dpi = 300, limitsize = TRUE)

ggsave("../images_to_export/GCSKO_sexbranch_dot_female.png", plot = dot_plot_female, device = "png", path = NULL, scale = 1, width = 30, height = 60, units = "cm", dpi = 300, limitsize = TRUE)
```








Pheatmap version of heatmap old cold to make main heatmap (NOT RUN)

Make annotations to add to the heatmap
```{r}
## change names for row names to include "module " at the begining of them
row.names(agg_mat) <- stringr::str_c("Module ", row.names(agg_mat))

## add number of cells to the rownames for the module
for(i in seq_along(genes_per_module$Freq)){
  row.names(agg_mat)[i] <- stringr::str_c(row.names(agg_mat)[i]," (n = " ,genes_per_module$Freq[i], ")")
}

## create annotation of clusters for pheatmap:
cluster_anno <- data.frame(cluster = unique(colData(monocle.object)$seurat_clusters))
row.names(cluster_anno) <- cluster_anno$cluster

## clusters were defined earlier as:
male_clusters <- c("13", "5", "11", "25", "1", "17", "10", "24", "14", "27", "19")
female_clusters <- c("16", "22", "23", "15", "21", "30", "4", "3", "18", "7", "8", "6", "20", "12", "26")
asex_clusters <- c("0", "9", "28", "2", "29")

## add identities to the column
cluster_anno$group <- NA
cluster_anno$group[which(cluster_anno$cluster %in% asex_clusters)] <- "Asexual"
cluster_anno$group[which(cluster_anno$cluster %in% male_clusters)] <- "Male"
cluster_anno$group[which(cluster_anno$cluster %in% female_clusters)] <- "Female"
cluster_anno <- cluster_anno[ , 2, drop = FALSE]
cluster_anno

## add median pseudotime per cluster
## help here:
## https://stackoverflow.com/questions/54360855/calculate-mean-for-column-grouped-by-values-of-two-other-columns
## make subsetted dataframe
df_median_pt <- meta_data_df[ ,c("pt", "seurat_clusters")]
## apply across dataframe to get median
mean.df1 <- tapply(df_median_pt$pt, list(df_median_pt$seurat_clusters), median)
mean.df2 <- as.data.frame(as.table(mean.df1))
names(mean.df2) <- c("seurat_clusters", "pt_Median")
rownames(mean.df2) <- mean.df2$seurat_clusters
## to make each value have the mean in the OG dataframe
#merge(df_median_pt, mean.df2)
## add to annotation dataframe
cluster_anno <- merge(cluster_anno, mean.df2, by=0)

## add rownames to dataframe
rownames(cluster_anno) <- cluster_anno$Row.names
## subset to have only info of interest
cluster_anno <- cluster_anno[,c(2,4)]
names(cluster_anno) <- c("Identity", "Median_Pseudotime_of_Cluster")
```

#### WT cells by modules over pt (central panel)

```{r, fig.height = 10, fig.width = 12}
## make annotation colours
annotation_colours <- list(Identity = c(Male="#016c00", Female="#a52b1e", Asexual= "#0052c5"),
                           Median_Pseudotime_of_Cluster = magma(12, direction = 1))

## reorder the levels
## make df of data
agg_mat_df <- as.data.frame(agg_mat)
## remove levels in my_levels that are not present here - i.e. clusters that are missing because they are not represented in the 10X data
my_levels_10x_data <- my_levels_sex[which(my_levels_sex %in% colnames(agg_mat_df))]
## sort the values
agg_mat_df <- agg_mat_df[ ,(match(my_levels_10x_data, colnames(agg_mat_df)))]

## order 
#cluster_anno <- cluster_anno[(match(my_levels_10x_data, rownames(cluster_anno))), ]

## reorder columns 
## first, order the annotation
cluster_anno <- cluster_anno[with(cluster_anno, order(Identity, Median_Pseudotime_of_Cluster)),]

## remove the NAs from this
cluster_anno <- cluster_anno[complete.cases(cluster_anno),]

agg_mat_df <- agg_mat_df[ ,match(rownames(cluster_anno), colnames(agg_mat_df))]

## plot heatmap
pheatmap::pheatmap(agg_mat_df, 
                   scale="row",
                   cluster_cols = FALSE,
                   clustering_method="ward.D2", 
                   annotation_col = cluster_anno, 
                   annotation_colors = annotation_colours, 
                   cutree_rows = 12)

#, gaps_col = c(28,29,37)
```

```{r, fig.height = 7, fig.width = 10}
#row.names(agg_mat) <- factor(row.names(agg_mat), levels = row.names(agg_mat)[module_dendro$order])

## plot heatmap
#pheatmap::pheatmap(agg_mat_df, 
  #                  scale="column",
  #                  cluster_cols = TRUE,
  #                  cluster_rows = module_dendro,
  #                  #clustering_method="ward.D2",
  #                  cutree_rows = 5,
  #                  annotation_col = cluster_anno, 
  #                  annotation_colors = annotation_colours) + 
  # theme(legend.position = "bottom")
```
