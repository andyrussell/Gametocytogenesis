---
subtitle: 'Gametocyte Development in <i>Plasmodium berghei</i>'
title: |
  ![](../GCSKO_logo.jpg){width=300px}  
  Pseudotime Sexual Branch wild-type cells only
author: "[Andrew Russell](https://ajcrussell.wixsite.com/mysite/about)"
institute: Wellcome Sanger Institute
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_notebook:
    theme: cosmo
    toc: yes
    toc_depth: 3
    #toc_float: yes
    df_print: paged
---
***
# 1. Introduction and Aims {.tabset}

We have merged the two datasets together in GCSKO_merge_wt.Rmd. We also subsetted out the pre-sexual-branch and the sexual cells (male and female) and stored them in a Seurat object called tenx.justwt.integrated.sex Here, we will perform pseudotime analysis on the dataset and build modules of genes that show similar expression across this pseudotime.

# 2. Read in the data  {.tabset}

## Load/Install the Required Packages

```{r load packages, echo = FALSE}
## CRAN packages

## Patchwork is needed to stich plots together using '+'
if(require("patchwork", quietly = TRUE)){
    print("patchwork is loaded correctly")
} else {
    print("trying to install patchwork")
    install.packages("patchwork")
    if(require(patchwork)){
        print("patchwork installed and loaded")
    } else {
        stop("could not install patchwork")
    }
}

## viridis allows different colours to be added to plots
if(require("viridis", quietly = TRUE)){
    print("viridis is loaded correctly")
} else {
    print("trying to install viridis")
    install.packages("viridis")
    if(require(viridis)){
        print("viridis installed and loaded")
    } else {
        stop("could not install viridis")
    }
}

## Seurat is needed for most of this script
if(require("Seurat", quietly = TRUE)){
    print("Seurat is loaded correctly")
} else {
    print("trying to install Seurat")
    install.packages("Seurat")
    if(require(Seurat)){
        print("Seurat installed and loaded")
    } else {
        stop("could not install Seurat")
    }
}

## cowplot is needed for plots in this script
if(require("cowplot")){
    print("cowplot is loaded correctly")
} else {
    print("trying to install cowplot")
    install.packages("cowplot")
    if(require(cowplot)){
        print("cowplot installed and loaded")
    } else {
        stop("could not install cowplot")
    }
}

## gridExtra is needed for grid graphics to plot multiple plots in the same view
if(require("gridExtra")){
    print("gridExtra is loaded correctly")
} else {
    print("trying to install gridExtra")
    install.packages("gridExtra")
    if(require(gridExtra)){
        print("gridExtra installed and loaded")
    } else {
        stop("could not install gridExtra")
    }
}

## grid is needed for grid.arrange function to change size of title
if(require("grid")){
    print("grid is loaded correctly")
} else {
    print("trying to install grid")
    install.packages("grid")
    if(require(grid)){
        print("grid installed and loaded")
    } else {
        stop("could not install grid")
    }
}

##for doing bulk correlation calculations
if(require("Hmisc")){
    print("Hmisc is loaded correctly")
} else {
    print("trying to install Hmisc")
    install.packages("Hmisc")
    if(require(Hmisc)){
        print("Hmisc installed and loaded")
    } else {
        stop("could not install Hmisc")
    }
}

## reshape2 to melt dataframes for plotting:
if(require("reshape2")){
    print("reshape2 is loaded correctly")
} else {
    print("trying to install reshape2")
    install.packages("reshape2")
    if(require(reshape2)){
        print("reshape2 installed and loaded")
    } else {
        stop("could not install reshape2")
    }
}

## to work with data frames:
if(require("dplyr")){
    print("dplyr is loaded correctly")
} else {
    print("trying to install dplyr")
    install.packages("dplyr")
    if(require(dplyr)){
        print("dplyr installed and loaded")
    } else {
        stop("could not install dplyr")
    }
}

## this allows us to use the colorRamp2 function which allows us to plot nice colour gradient pals:
if(require("circlize")){
    print("circlize is loaded correctly")
} else {
    print("trying to install circlize")
    install.packages("circlize")
    if(require(circlize)){
        print("circlize installed and loaded")
    } else {
        stop("could not install circlize")
    }
}

## non-CRAN packages

## monocle3 to calculate pseudotime:
if(require("monocle3")){
    print("monocle3 is loaded correctly")
} else {
    print("Please install monocle3 (https://cole-trapnell-lab.github.io/monocle3/docs/installation/)")
}

## destiny is used for diffusion plots (DiffusionMap function)
if(require("destiny")){
    print("destiny is loaded correctly")
} else {
  print("trying to install destiny")
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install("destiny")
  if(require(destiny)){
        print("destiny installed and loaded")
    } else {
        stop("could not install destiny")
    }
}

#set the seed for both the mixture models and also for the sample function later on:
set.seed(-92497)
```

## load data

```{r}
## load sex only branch cells saved from GCSKO_Sex_Branch_Analysis.Rmd
## Restore the objects
## load sex branch dataset
tenx.justwt.integrated.sex <- readRDS("../data_to_export/tenx.justwt.integrated.sex.RDS")
## load full dataset
#tenx.mutant.integrated <- readRDS("../data_to_export/tenx.mutant.integrated.RDS")
```

```{r}
## add old pt values
## these values are calculated in hte GCSKO_pseudotime_allcells.Rmd script and so were added after the object was split into sex only.
#tenx.all <- readRDS("../data_to_export/tenx.mutant.integrated.RDS")
#tenx.all.meta <- as.data.frame(tenx.all@meta.data)
#tenx.all.meta <- tenx.all.meta[which(rownames(tenx.all.meta) %in% rownames(tenx.mutant.integrated.sex@meta.data)),]
#tenx.mutant.integrated.sex <- AddMetaData(tenx.mutant.integrated.sex, tenx.all.meta$old_pt_values, col.name = "old_pt_values")
## then remove these objects so they don't use up memory
#rm(tenx.all, tenx.all.meta)
```

Add a meta.data column so that 10X is listed as WT:
```{r}
## get cells that are filtered out
mutant_cells <- which(tenx.justwt.integrated.sex$experiment == "mutants")

## make extra column in plotting df
tenx.justwt.integrated.sex@meta.data$identity_name_combined <- "WT_10X"
tenx.justwt.integrated.sex@meta.data$identity_name_combined[mutant_cells] <- tenx.justwt.integrated.sex@meta.data$identity_name_updated[mutant_cells]

## check
table(tenx.justwt.integrated.sex@meta.data$identity_name_combined)
```

```{r}
## create a list of our mutant gene IDs
list_of_mutant_genes <- c("PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-1144800", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")
```

Read in gene annotations
```{r}
gene_annotations <- read.table("../data/Reference/GenesByTaxon_Summary.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)
dim(gene_annotations)

## convert _ to -
gene_annotations$Gene.ID <- gsub("_", "-", gene_annotations$Gene.ID)
```

# 3. Monocle on sex cells {.tabset}

## calculate pseudotime and modules

#### Preparation
```{r}
## extracts only 10x cells and also remove cluster 0 cells 
wt_cells <- rownames(tenx.justwt.integrated.sex@meta.data[which(tenx.justwt.integrated.sex@meta.data$identity_name_combined == "WT_10X" & !tenx.justwt.integrated.sex@meta.data$seurat_clusters == "3" & !tenx.justwt.integrated.sex@meta.data$seurat_clusters == "6"),])

## make a new Seurat of this
seurat.object <-subset(tenx.justwt.integrated.sex, cells = wt_cells)

## check that this is the same as the pb_sex_filtered object
#data_test <- as(as.matrix(GetAssayData(pb_sex_filtered, assay = "RNA", slot = "data")), 'sparseMatrix')
#is.equal
#is.identical

## extract counts and pheno:
## the reason we use the integrated and then subsetted is because these cells have been normalised whereas the cells in pb_sex_filtered have not been normalised (well they have but with doublets in them)
data <- as(as.matrix(GetAssayData(seurat.object, assay = "RNA", slot = "data")), 'sparseMatrix')
## make phenodata
pd <- data.frame(seurat.object@meta.data)
## keep only the columns that are relevant in metadata
#pData <- pd %>% select(orig.ident, nCount_RNA, nFeature_RNA)
## make gene metadata
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

## Construct monocle cds
monocle.object <- new_cell_data_set(expression_data = data, cell_metadata = pd, gene_metadata = fData)

## preprocess
monocle.object = preprocess_cds(monocle.object, num_dim = 50, norm_method = "none")
### if using integrated data:
# norm_method = "none", alignment_group = "~ experiment"

## plot jack straw plot
#plot_pc_variance_explained(monocle.object)

#monocle.object = reduce_dimension(monocle.object, reduction_method = "UMAP", preprocess_method = "PCA", umap.metric = "euclidean", umap.n_neighbors = 50, umap.min_dist = 0.5, verbose = FALSE)

#plot_cells(monocle.object, color_cells_by="experiment")

## graph learning

## add UMAP from Seurat
monocle.object@int_colData@listData$reducedDims@listData[["UMAP"]] <- seurat.object@reductions[["umap"]]@cell.embeddings
## if you want the old UMAP from the original all cells one, use: "DIM_UMAP"

## cluster
## this is essential to run the learn_graph function later on
monocle.object = cluster_cells(monocle.object)

## plot initial clustering by monocle
#plot_cells(monocle.object, color_cells_by="cluster", group_cells_by="partition", x = 2, y = 1)

## map pseudotime
monocle.object = learn_graph(monocle.object, learn_graph_control=list(ncenter=550, minimal_branch_len = 30), use_partition = FALSE)
# learn_graph_control=list(ncenter=500) - play with this parameter - lower tends to give fewer branches and higher tends to give more
# 500 - old analysis
# 250 - new analysis 

## Plot cells
plot_cells(monocle.object, color_cells_by="monocle_sex", group_cells_by="partition", x = 1, y = 2)
```

Redefine the identities of the male and female cells 

male
```{r}
# monocle.object_male <- choose_graph_segments(monocle.object)
```
female
```{r}
# monocle.object_female <- choose_graph_segments(monocle.object)
```
bipotential
```{r}
#monocle.object_bipot <- choose_graph_segments(monocle.object)
```
asexual
```{r}
#monocle.object_asex <- choose_graph_segments(monocle.object)
```
asexual fate
```{r}
#monocle.object_asex_fate <- choose_graph_segments(monocle.object)
```

check
```{r}
# df_freq <- data.frame(table(c(colnames(monocle.object_male), colnames(monocle.object_female), colnames(monocle.object_bipot), colnames(monocle.object_asex), colnames(monocle.object_asex_fate))))
# paste("number of cells in seurat object is", length(colnames(monocle.object)), ". The number of cells selected here with an identitity is", dim(df_freq)[1])
# df_freq <- df_freq[df_freq$Freq > 1, ]
# df_freq
```
Inspect where these missing cells are:
```{r}
# '%ni%' <- Negate('%in%')
# 
# not_assigned_cells <- colnames(monocle.object)[colnames(monocle.object) %ni% c(colnames(monocle.object_male), colnames(monocle.object_female), colnames(monocle.object_bipot), colnames(monocle.object_asex), colnames(monocle.object_asex_fate))]
# 
# DimPlot(seurat.object, repel = TRUE, label.size = 5, pt.size = 0.5, cells.highlight = not_assigned_cells, dims = c(2,1), reduction = "DIM_UMAP") +
#   coord_fixed() + 
#   scale_color_manual(values=c("#000000", "#f54e1e"))
```

```{r}
# ## create annotation dataframe from these results:
# df_monocle_sexes <- rbind(data.frame("cell_name" = colnames(monocle.object_male), "sex" = rep("Male", length(colnames(monocle.object_male)))),
#                           data.frame("cell_name" = colnames(monocle.object_female), "sex" = rep("Female", length(colnames(monocle.object_female)))),
#                           data.frame("cell_name" = colnames(monocle.object_bipot), "sex" = rep("Bipotential", length(colnames(monocle.object_bipot)))),
#                           data.frame("cell_name" = colnames(monocle.object_asex), "sex" = rep("Asexual", length(colnames(monocle.object_asex)))),
#                           data.frame("cell_name" = colnames(monocle.object_asex_fate), "sex" = rep("Asexual_Fate", length(colnames(monocle.object_asex_fate)))),
#                           data.frame("cell_name" = not_assigned_cells, "sex" = rep("Unassigned", length(not_assigned_cells)))
#                           )
# 
# dim(df_monocle_sexes)
# 
# ## order like the metadata
# df_monocle_sexes <- df_monocle_sexes[match(rownames(monocle.object@colData), df_monocle_sexes$cell_name), ]
# 
# ## add this back into the monocle object
# monocle.object@colData$Sexes_monocle <- df_monocle_sexes$sex
```

#### Pseudotime Calculation
```{r}
## Order the cells and calculate pseudotime
monocle.object = order_cells(monocle.object)

## Plot
umap_pt <- plot_cells(monocle.object, color_cells_by = "pseudotime", label_cell_groups=FALSE, cell_size = 1, x = 1, y = 2, label_branch_points=FALSE, label_leaves=FALSE, label_groups_by_cluster=FALSE, label_roots = FALSE) +
  coord_fixed() +
  theme_void() +
  labs(title = "Pseudotime") +
  theme(plot.title = element_text(hjust = 0.5, size=15), legend.position="bottom", legend.title=element_text (size=10), legend.text=element_text(size=10)) + 
  guides(colour = guide_colourbar(barwidth = 10, barheight = 0.5, title = "Pseudotime"))

## view
umap_pt
```

#### Check how well it correlates with the original pseudotime

when pseudotime was calculated on the whole object

```{r}
library(ggpubr)
## extract pseudotime values:
pt_values_new <- as.data.frame(pseudotime(monocle.object, reduction_method = "UMAP"))
pt_values_new$cell_name <- rownames(pt_values_new)
meta_data_df <- as.data.frame(monocle.object@colData)
meta_data_df$cell_name <- rownames(meta_data_df)
meta_data_df <- merge(meta_data_df, pt_values_new, by = "cell_name")
names(meta_data_df)[ncol(meta_data_df)]<- "pt"

ggplot(meta_data_df, aes(x = old_pt_values, y = pt, colour = monocle_sex)) + 
  geom_point() +  
  geom_smooth(method = "lm", se = FALSE) +
  theme_classic() + stat_cor(method = "pearson")
```

#### Module Construction
```{r}
## find genes that change as a function of pt:
monocle.object_pr_test_res <- graph_test(monocle.object, neighbor_graph="principal_graph", cores=8)

## find significant genes
## I used 0.05 previously in all cells 
## 2884 w. p = 0.01, 3260 w. p = 0.05
pr_deg_ids <- row.names(subset(monocle.object_pr_test_res, q_value < 0.05))

## collect into modules
gene_module_df_sex <- find_gene_modules(monocle.object[pr_deg_ids,], resolution=c(10^seq(-6,2)), random_seed = 1234)

## how many genes in modules?
dim(gene_module_df_sex)
```

```{r, echo = FALSE}
paste("there are", length(levels(gene_module_df_sex$module)), "modules")
```

## Plot Modules

#### General Module Composition

Make a dataframe to plot by aggregating clusters vs. modules
```{r}
## make cell group df
cell_group_df <- tibble::tibble(cell=row.names(colData(monocle.object)), cell_group=colData(monocle.object)$seurat_clusters)

## make plotting df
agg_mat <- aggregate_gene_expression(monocle.object, gene_module_df_sex, cell_group_df)
```

Find out how many genes there are per total so we can add this to the plot
```{r}
## how many genes per module?
genes_per_module <- as.data.frame(table(gene_module_df_sex$module))
genes_per_module
```

Find out which modules our mutant genes reside in
```{r}
## create a list of our mutant gene IDs
list_of_mutant_genes <- c("PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")

## make a dataframe to convert the gene IDs into actual IDs
ss2_mutants_final <- readRDS("../data_to_export/ss2_mutants_final.RDS")
df_mutant_ids <- as.data.frame(unique(cbind(ss2_mutants_final@meta.data$identity_gene_updated, ss2_mutants_final@meta.data$identity_updated, ss2_mutants_final@meta.data$identity_name_updated)))[-c(2),]
rm(ss2_mutants_final)
# remove the "820" bit on 10
df_mutant_ids$V1 <- gsub("_820", "", df_mutant_ids$V1)
# change the underscore (_) to a dash (-) in gene IDs
df_mutant_ids$V1 <- gsub("_", "-", df_mutant_ids$V1)
names(df_mutant_ids) <- c("gene_ID", "mutant_identity", "mutant_identity_2")

## subset modules df to include only mutant gene IDs
df_mutant_gene_modules <- as.data.frame(gene_module_df_sex[which(gene_module_df_sex$id %in% list_of_mutant_genes),])
names(df_mutant_gene_modules)[1] <- "gene_ID"

## merge dataframes
df_mutant_gene_modules <- merge(df_mutant_gene_modules, df_mutant_ids, by = "gene_ID")

## Inspect
df_mutant_gene_modules[order(df_mutant_gene_modules$module), ]
```

so modules of interest are:
```{r}
table(df_mutant_gene_modules$module)
```

Which modules do other genes of interest lie in?:
```{r}
## landmark genes (genes of interest)
# AP2G - PBANKA-1437500
# AP2 - PBANKA-0909600 - from poran paper
# AP2G-2 - PBANKA-1034300 
# ccp2 - "PBANKA-1319500" - female 820
# p25 - "PBANKA-0515000" - female
# p28 - "PBANKA-0514900" - female
# ccp3 - "PBANKA-1035200" - female -  https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5909122/
# nek4 - "PBANKA-0616700" - female
# ap2-fg - "PBANKA-1415700" - female 
# dozi - "PBANKA-1217700" - female
# MG1 - "PBANKA-0416100" - male 820
# hap2 - "PBANKA-1212600" - male
# MAPK2 - "PBANKA-0933700" - male
# nek1 - "PBANKA-1443000" - male
# cdpk4 - "PBANKA-0615200" - male

## create a list of landmark genes
list_of_landmark_genes <- c("PBANKA-1437500",
                            "PBANKA-0909600",
                            "PBANKA-1034300", 
                            "PBANKA-1319500", 
                            "PBANKA-0515000",
                            "PBANKA-0514900",
                            "PBANKA-1035200",
                            "PBANKA-0616700",
                            "PBANKA-1415700",
                            "PBANKA-1217700",
                            "PBANKA-0416100", 
                            "PBANKA-1212600",
                            "PBANKA-0933700",
                            "PBANKA-1443000",
                            "PBANKA-0615200")

name_of_landmark_genes <- c("AP2-G", 
                            "AP2_poran", 
                            "AP2-G2", 
                            "ccp2", 
                            "p25", 
                            "p28",
                            "ccp3",
                            "nek4",
                            "ap2-fg",
                            "DOZI",
                            "mg1", 
                            "hap2", 
                            "mapk2",
                            "nek1",
                            "cdpk4")

## make a df
name_of_landmark_genes <- data.frame("gene_name" = name_of_landmark_genes, "id" = list_of_landmark_genes)

## make dataframe
df_landmark_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% list_of_landmark_genes),]

## merge dataframes
df_landmark_gene_modules <- merge(df_landmark_gene_modules, name_of_landmark_genes, by = "id")

## inspect
df_landmark_gene_modules[order(df_landmark_gene_modules$module), ]
```

enrichment of screen hits in modules
```{r}
## read in screen hits
library("readxl")
screen_hits <- read_excel("../data/Screen/Modules_Clusters_Phenotypes.xlsx")

## get only hits
screen_hits_selected <- screen_hits[which(screen_hits$`Gam phenotype screen` == "Both" | screen_hits$`Gam phenotype screen` == "Females" | screen_hits$`Gam phenotype screen` == "Males"), ] 

## extract gene IDs
gene_hits <- screen_hits_selected$`new gene ID`
## change the underscore to a dash
gene_hits <- gsub("_", "-", gene_hits)

## find out which modules they are in
df_hits_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% gene_hits),]
print("screen hits by module")
table(df_hits_gene_modules$module)

## get the number genes screened in that module
screen_hits_screened <- screen_hits[which(screen_hits$`Gam phenotype screen` == "Both" | screen_hits$`Gam phenotype screen` == "Females" | screen_hits$`Gam phenotype screen` == "Males" | screen_hits$`Gam phenotype screen` == "None" | screen_hits$`Gam phenotype screen` == "male not enough power"), ] 
## extract gene IDs
genes_screened <- screen_hits_screened$`new gene ID`
## change the underscore to a dash
genes_screened <- gsub("_", "-", genes_screened)
## find out which modules they are in
df_screened_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% genes_screened),]
print("total genes screened in this module")
table(df_screened_gene_modules$module)

## make a table with this info
pc_screened <- data.frame(hits = table(df_hits_gene_modules$module), screened =  table(df_screened_gene_modules$module))[,-3]
names(pc_screened) <- c("module", "hits", "screened")
pc_screened$pc <- (pc_screened$hits /pc_screened$screened)*100

## view
pc_screened
```
Further investigation of screen hits
```{r}
## rename df
df_screen_hits_selected <- as.data.frame(screen_hits_selected)
df_screen_hits_selected$'new gene ID' <- gsub("_", "-", df_screen_hits_selected$'new gene ID')
names(df_screen_hits_selected)[2] <- "id"
df_gene_module_df_sex <- as.data.frame(gene_module_df_sex)

## merge dfs together
screen_hits_modules <- merge(df_screen_hits_selected, df_gene_module_df_sex, by = "id")

## view
screen_hits_modules
```

DOZI-regulated genes

Find out how many of the genes in each module has a DOZI-regulated gene

```{r}
DOZI_regulated_genes <-
read.csv(file = "../data/Reference/DOZI_regulated_genes.csv", header = TRUE)

## extract gene IDs
dozi_genes <- DOZI_regulated_genes[DOZI_regulated_genes$DOZI_regulated. == "YES", ]$Gene_ID_PB
## change the underscore to a dash
dozi_genes <- gsub("_", "-", dozi_genes)

## find out which modules they are in
df_dozi_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% dozi_genes),]
print("dozi genes by module")
table(df_dozi_gene_modules$module)
```

#### Visualise module expression

plot out modules
```{r, fig.height = 7, fig.width = 7}
## make aggregated df again so you can edit it
agg_mat <- aggregate_gene_expression(monocle.object, gene_module_df_sex, cell_group_df)

## h clust the aggregated matrix
module_dendro <- hclust(dist(agg_mat))

## use these clusters to reorder the modules
gene_module_df_sex$module <- factor(gene_module_df_sex$module, levels = row.names(agg_mat)[module_dendro$order])

## plot
UMAP_modules <- plot_cells(monocle.object, genes=gene_module_df_sex %>% filter(module %in% c(1:20)),
           cell_size = 2, 
           x = 1, y = 2,
           label_cell_groups=FALSE,
           scale_to_range = TRUE,
           show_trajectory_graph=FALSE) +
                          scale_colour_viridis_c(name = "expression", option = "C", alpha = 1) +
                          coord_fixed() +
                          theme_void() +
                          theme(legend.position = "bottom", strip.text.x = element_text(size = 15))

## view
UMAP_modules
```
save
```{r}
#ggsave("../images_to_export/GCSKO_sexbranch_umap_modules.png", plot = UMAP_modules, device = "png", path = NULL, scale = 1, width = 30, height = 30, units = "cm", dpi = 300, limitsize = TRUE)
```

```{r}
## make a dataframe of genes per module
genes_per_module <- as.data.frame(table(gene_module_df_sex$module))

## inspect
genes_per_module
```

```{r, fig.height = 8, fig.width = 12}
## A. Preparation of dataframe

## prepare custom dataframe for all cells by modules:
agg_mat_no_group <- aggregate_gene_expression(monocle.object, gene_module_df_sex, scale_agg_values = TRUE)

## B. annotations

## make an anotation
## add pt to the monocle object
monocle.object@colData$pt_sex <- as.data.frame(pseudotime(monocle.object, reduction_method = "UMAP"))[,1]
## make an annotation dataframe
anno_no_group <- data.frame(monocle.object@colData$monocle_sex, monocle.object@colData$pt_sex, as.factor(monocle.object@colData$Prediction.Spearman._Kasia), row.names = rownames(monocle.object@colData))
names(anno_no_group) <- c("Sex", "Pseudotime", "Real_time_prediction")

## make annotation colours
annotation_colours <- list(Sex = c(Male="#016c00", Female="#a52b1e", Bipotential = "#ffe400", Asexual_Early = "#0052c5"),
                           Pseudotime = plasma(12, direction = 1),
                           Real_time_prediction = c("0" = viridis(8, direction = 1)[1] ,"1" =  viridis(8, direction = 1)[2] ,"4" = viridis(8, direction = 1)[3] ,"6" = viridis(8, direction = 1)[4] ,"8" = viridis(8, direction = 1)[5]  ,"12"  = viridis(8, direction = 1)[6]  ,"18" = viridis(8, direction = 1)[7]  ,"24" = viridis(8, direction = 1)[8]))

## change the order of the cols (cells) in data frame
col.order <- rownames(anno_no_group[with(anno_no_group, order(Sex, Pseudotime)), ])
agg_mat_no_group <- agg_mat_no_group[,col.order]

## reorder the rows (gene modules) in the data frame so they are in pt order
## define the order visually and using the clusters originally produced
row.order <- c("3", "17",
               "6", "9", "10", "13", "16", "1", "7",
               "18", "2", "5",
               "4", "14", "15", "11", "8", "12"
               )
## reorder using new order
agg_mat_no_group <- agg_mat_no_group[row.order, ]

## for cuts in columns - used later to count number of cells in each cat
df_meta <- as.data.frame(monocle.object@colData)
female_cells <- rownames(df_meta[which(df_meta$monocle_sex == "Female"), ])
male_cells <- rownames(df_meta[which(df_meta$monocle_sex == "Male"), ])
bi_cells <- rownames(df_meta[which(df_meta$monocle_sex == "Bipotential"), ])
asex_cells <- rownames(df_meta[which(df_meta$monocle_sex == "Asexual_Early"), ])
rm(df_meta)

## add module and the number of cells to the row
## change names for row names to include "module " at the begining of them
labels.row <- stringr::str_c("Module ", row.names(agg_mat_no_group))
## reorder frequency so that it is matching our matrix
genes_per_module_ordered <- genes_per_module[match(row.names(agg_mat_no_group), genes_per_module$Var1), ]
## add number of cells to the rownames for the module
for(i in seq_along(genes_per_module_ordered$Freq)){
  labels.row[i] <- stringr::str_c(labels.row[i]," (n = " ,genes_per_module_ordered$Freq[i], ")")
}

## C. Plotting

## plot
heatmap_main <- pheatmap::pheatmap(agg_mat_no_group, 
                   #scale="row",
                   cluster_cols = FALSE,
                   cluster_rows = FALSE,
                   ## others: ward.D2,
                   #clustering_method="complete",
                   scale = "none",
                   show_colnames = FALSE,
                   labels_row = labels.row,
                   fontsize_row = 15,
                   fontsize = 12,
                   gaps_col = c(length(asex_cells), length(c(asex_cells,bi_cells)), length(c(asex_cells,bi_cells,female_cells))),
                   annotation_col = anno_no_group, 
                   annotation_colors = annotation_colours, 
                   cutree_rows = 6)

## view
heatmap_main
```
save
```{r}
ggsave("../images_to_export/GCSKO_sexbranch_heatmap.png", plot = heatmap_main, device = "png", path = NULL, scale = 1, width = 21, height = 21, units = "cm", dpi = 300, limitsize = TRUE)
```



# 4. Mapping on mutants {.tabset}

```{r}

```


Seurat method

```{r}
pancreas.anchors <- FindTransferAnchors(reference = seurat.object, query = SMARTSEQ, 
    dims = 1:30)
predictions <- TransferData(anchorset = pancreas.anchors, refdata = seurat.object$monocle_sex, 
    dims = 1:30)
pancreas.query <- AddMetaData(pancreas.query, metadata = predictions)
```


# Final Figures

```{r}
## C
## This shows the cells selected for module analysis 
## this package allows easy extraction of viridis values used in the pt plots
library("colourvalues") # allows 
## extract colour hex values 
monocle.object@colData$pt_sex_col <- colour_values(monocle.object@colData$pt_sex, palette = "plasma")

## load in the whole dataset if you haven't already loaded it in
#tenx.justwt.integrated <- readRDS("../data_to_export/tenx.justwt.integrated.RDS")

## extract metadata
df_plot <- tenx.justwt.integrated@meta.data

## add umap - merge on row names and then make sure row names are not dropped or added
df_plot <- transform(merge(df_plot, tenx.justwt.integrated@reductions[["umap"]]@cell.embeddings, by=0, all=TRUE), row.names=Row.names, Row.names=NULL)

## make new col for colours - and make everything grey
df_plot$hex <- "#e7e7e7"

## extract colours for highlighted cells 
df_plot_2 <- as.data.frame(monocle.object@colData[,"pt_sex_col", drop = FALSE])

## then merge this back into the colour column, whilst matching the rows
rownames_to_match <- rownames(df_plot[rownames(df_plot) %in% rownames(df_plot_2), ])

df_plot$hex[rownames(df_plot) %in% rownames(df_plot_2)] <- df_plot_2[match(rownames_to_match, rownames(df_plot_2)), , drop = FALSE][ ,1]

### make character so ggplto2 recognises them
df_plot$hex <- as.character(df_plot$hex)

## reorder so that the voloured points are on top
## this is a bit hacky but you can split the data frame and then remerge, since the command commented out will still put E above other values - this command was just order by the col hex
df_plot_1 <- df_plot[!(df_plot$hex == "#e7e7e7"), ]
df_plot_2 <- df_plot[(df_plot$hex == "#e7e7e7"), ]
df_plot <- rbind(df_plot_2, df_plot_1)
rm(df_plot_2, df_plot_1)

## add tree
##The tree for monocle is located here:
# monocle.object@principal_graph_aux[["UMAP"]]$dp_mst 
ica_space_df <- t(monocle.object@principal_graph_aux[["UMAP"]]$dp_mst) %>%
      as.data.frame() %>%
      dplyr::select_(prin_graph_dim_1 = "UMAP_1", prin_graph_dim_2 = "UMAP_2") %>%
      dplyr::mutate(sample_name = rownames(.),
                    sample_state = rownames(.))

dp_mst <- monocle.object@principal_graph[["UMAP"]]

edge_df <- dp_mst %>%
      igraph::as_data_frame() %>%
      dplyr::select_(source = "from", target = "to") %>%
      dplyr::left_join(ica_space_df %>%
                         dplyr::select_(
                           source="sample_name",
                           source_prin_graph_dim_1="prin_graph_dim_1",
                           source_prin_graph_dim_2="prin_graph_dim_2"),
                       by = "source") %>%
      dplyr::left_join(ica_space_df %>%
                         dplyr::select_(
                           target="sample_name",
                           target_prin_graph_dim_1="prin_graph_dim_1",
                           target_prin_graph_dim_2="prin_graph_dim_2"),
                       by = "target")


umap_zoom_plot <- ggplot(df_plot, aes(x = UMAP_1, y = UMAP_2, colour = hex)) +
                         geom_point(size = 2) +
                        ## need this to tell ggplot2 to map to values
                         scale_colour_identity() +
                        ## fix coordinates
                         coord_fixed() +
                         theme_void() + 
                         theme(legend.position = "none") +
                         geom_segment(aes_string(x="source_prin_graph_dim_1",
                                                 y="source_prin_graph_dim_2",
                                                 xend="target_prin_graph_dim_1",
                                                 yend="target_prin_graph_dim_2"
                                                 ),
                                      data=edge_df, inherit.aes = FALSE
                                      )
  
  
umap_zoom_plot

## remove big dataset
#rm(tenx.justwt.integrated)
```

```{r}
# Extract the legend. Returns a gtable
leg <- get_legend(umap_pt)

# Convert to a ggplot and print
legend_d <- as_ggplot(leg)
```

save
```{r}
ggsave("../images_to_export/Figure_D.png", plot = umap_zoom_plot, device = "png", path = NULL, scale = 1, width = 21, height = 29.7, units = "cm", dpi = 300, limitsize = TRUE)
ggsave("../images_to_export/Figure_D_legend.png", plot = legend_d, device = "png", path = NULL, scale = 1, width = 21, height = 29.7, units = "cm", dpi = 300, limitsize = TRUE)
```



# Appendix {.tabset}

## Session Info 
```{r, echo = FALSE}
sessionInfo()
```

### Scaling values in the aggregated heatmap
```{r}
getAnywhere(aggregate_gene_expression)
```

```{r}
## This does the above aggregation function but manually to understand it better.
## This is how we execute the function above.
#agg_mat_no_group <- aggregate_gene_expression(monocle.object, gene_module_df_sex, scale_agg_values = TRUE)

## define variables
# cds = monocle.object
# gene_group_df = gene_module_df_sex
# max_agg_value = 3
# min_agg_value = -3

## perform aggregation
# agg_mat <- normalized_counts(cds)
# gene_group_df <- as.data.frame(gene_group_df)
# gene_group_df <- gene_group_df[gene_group_df[, 1] %in% fData(cds)$gene_short_name | gene_group_df[, 1] %in% row.names(fData(cds)), , drop = FALSE]
# short_name_mask <- gene_group_df[[1]] %in% fData(cds)$gene_short_name
# if (any(short_name_mask)) {
#             geneids <- as.character(gene_group_df[[1]])
#             geneids[short_name_mask] <- row.names(fData(cds))[match(geneids[short_name_mask], 
#                 fData(cds)$gene_short_name)]
#             gene_group_df[[1]] <- geneids
# }
# 
# agg_mat = as.matrix(monocle3:::my.aggregate.Matrix(agg_mat[gene_group_df[,1], ], as.factor(gene_group_df[, 2]), fun = "sum"))

## This scales aggregate values         
#         if (scale_agg_values) {
#             agg_mat <- t(scale(t(agg_mat)))
#             agg_mat[agg_mat < min_agg_value] <- min_agg_value
#             agg_mat[agg_mat > max_agg_value] <- max_agg_value
#         }

```

```{r}
## get an idea of the spread of z-score values 
# test <- (agg_mat_no_group)
# rowRanges(test)
# rowMeans(test)
# test <- t(agg_mat_no_group)
# names(test) = make.names(test)
# test = melt(test)
# ggplot(test, aes(x = Var2, y = value, group = Var2)) + geom_violin()
# rm(test)
```

In conclusion, the plots will look different if scaling is done by heatmap as it does not do the relimiting - i.e. anything < -3 and 3 < for the z-scores. the scaling is done on the transformed columns (e.g. when applying 'scale' to a matrix, it does it in a column-wise manner) which in this case, the modules are columns and so it does the correct scaling required. This is because the input is normalised cell counts and so the cells have already been scaled. 
