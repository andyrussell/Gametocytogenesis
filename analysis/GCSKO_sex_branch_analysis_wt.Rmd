---
subtitle: 'Gametocyte Development in <i>Plasmodium berghei</i>'
title: |
  ![](../GCSKO_logo.jpg){width=300px}  
  Pseudotime Sexual Branch wild-type cells only
author: "[Andrew Russell](https://ajcrussell.wixsite.com/mysite/about)"
institute: Wellcome Sanger Institute
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_notebook:
    theme: cosmo
    toc: yes
    toc_depth: 3
    #toc_float: yes
    df_print: paged
---
***
# 1. Introduction and Aims {.tabset}

We have merged the two datasets together in GCSKO_merge_wt.Rmd. We also subsetted out the pre-sexual-branch and the sexual cells (male and female) and stored them in a Seurat object called tenx.justwt.integrated.sex Here, we will perform pseudotime analysis on the dataset and build modules of genes that show similar expression across this pseudotime.

# 2. Read in the data  {.tabset}

## Load/Install the Required Packages

```{r load packages, echo = FALSE}
## CRAN packages

## Patchwork is needed to stich plots together using '+'
if(require("patchwork", quietly = TRUE)){
    print("patchwork is loaded correctly")
} else {
    print("trying to install patchwork")
    install.packages("patchwork")
    if(require(patchwork)){
        print("patchwork installed and loaded")
    } else {
        stop("could not install patchwork")
    }
}

## viridis allows different colours to be added to plots
if(require("viridis", quietly = TRUE)){
    print("viridis is loaded correctly")
} else {
    print("trying to install viridis")
    install.packages("viridis")
    if(require(viridis)){
        print("viridis installed and loaded")
    } else {
        stop("could not install viridis")
    }
}

## Seurat is needed for most of this script
if(require("Seurat", quietly = TRUE)){
    print("Seurat is loaded correctly")
} else {
    print("trying to install Seurat")
    install.packages("Seurat")
    if(require(Seurat)){
        print("Seurat installed and loaded")
    } else {
        stop("could not install Seurat")
    }
}

## cowplot is needed for plots in this script
if(require("cowplot")){
    print("cowplot is loaded correctly")
} else {
    print("trying to install cowplot")
    install.packages("cowplot")
    if(require(cowplot)){
        print("cowplot installed and loaded")
    } else {
        stop("could not install cowplot")
    }
}

## gridExtra is needed for grid graphics to plot multiple plots in the same view
if(require("gridExtra")){
    print("gridExtra is loaded correctly")
} else {
    print("trying to install gridExtra")
    install.packages("gridExtra")
    if(require(gridExtra)){
        print("gridExtra installed and loaded")
    } else {
        stop("could not install gridExtra")
    }
}

## grid is needed for grid.arrange function to change size of title
if(require("grid")){
    print("grid is loaded correctly")
} else {
    print("trying to install grid")
    install.packages("grid")
    if(require(grid)){
        print("grid installed and loaded")
    } else {
        stop("could not install grid")
    }
}

##for doing bulk correlation calculations
if(require("Hmisc")){
    print("Hmisc is loaded correctly")
} else {
    print("trying to install Hmisc")
    install.packages("Hmisc")
    if(require(Hmisc)){
        print("Hmisc installed and loaded")
    } else {
        stop("could not install Hmisc")
    }
}

## reshape2 to melt dataframes for plotting:
if(require("reshape2")){
    print("reshape2 is loaded correctly")
} else {
    print("trying to install reshape2")
    install.packages("reshape2")
    if(require(reshape2)){
        print("reshape2 installed and loaded")
    } else {
        stop("could not install reshape2")
    }
}

## to work with data frames:
if(require("dplyr")){
    print("dplyr is loaded correctly")
} else {
    print("trying to install dplyr")
    install.packages("dplyr")
    if(require(dplyr)){
        print("dplyr installed and loaded")
    } else {
        stop("could not install dplyr")
    }
}

## this allows us to use the colorRamp2 function which allows us to plot nice colour gradient pals:
if(require("circlize")){
    print("circlize is loaded correctly")
} else {
    print("trying to install circlize")
    install.packages("circlize")
    if(require(circlize)){
        print("circlize installed and loaded")
    } else {
        stop("could not install circlize")
    }
}

## non-CRAN packages

## monocle3 to calculate pseudotime:
if(require("monocle3")){
    print("monocle3 is loaded correctly")
} else {
    print("Please install monocle3 (https://cole-trapnell-lab.github.io/monocle3/docs/installation/)")
}

## destiny is used for diffusion plots (DiffusionMap function)
if(require("destiny")){
    print("destiny is loaded correctly")
} else {
  print("trying to install destiny")
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install("destiny")
  if(require(destiny)){
        print("destiny installed and loaded")
    } else {
        stop("could not install destiny")
    }
}

#set the seed for both the mixture models and also for the sample function later on:
set.seed(-92497)
```

## load data

```{r}
## load sex only branch cells saved from GCSKO_Sex_Branch_Analysis.Rmd
## Restore the objects
## load sex branch dataset
tenx.justwt.integrated.sex <- readRDS("../data_to_export/tenx.justwt.integrated.sex.RDS")
## load full dataset
#tenx.mutant.integrated <- readRDS("../data_to_export/tenx.mutant.integrated.RDS")
```

```{r}
## add old pt values
## these values are calculated in hte GCSKO_pseudotime_allcells.Rmd script and so were added after the object was split into sex only.
#tenx.all <- readRDS("../data_to_export/tenx.mutant.integrated.RDS")
#tenx.all.meta <- as.data.frame(tenx.all@meta.data)
#tenx.all.meta <- tenx.all.meta[which(rownames(tenx.all.meta) %in% rownames(tenx.mutant.integrated.sex@meta.data)),]
#tenx.mutant.integrated.sex <- AddMetaData(tenx.mutant.integrated.sex, tenx.all.meta$old_pt_values, col.name = "old_pt_values")
## then remove these objects so they don't use up memory
#rm(tenx.all, tenx.all.meta)
```

Add a meta.data column so that 10X is listed as WT:
```{r}
## get cells that are filtered out
mutant_cells <- which(tenx.justwt.integrated.sex$experiment == "mutants")

## make extra column in plotting df
tenx.justwt.integrated.sex@meta.data$identity_name_combined <- "WT_10X"
tenx.justwt.integrated.sex@meta.data$identity_name_combined[mutant_cells] <- tenx.justwt.integrated.sex@meta.data$identity_name_updated[mutant_cells]

## check
table(tenx.justwt.integrated.sex@meta.data$identity_name_combined)
```

```{r}
## create a list of our mutant gene IDs
list_of_mutant_genes <- c("PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-1144800", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")
```

Read in gene annotations
```{r}
gene_annotations <- read.table("../data/Reference/GenesByTaxon_Summary.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)
dim(gene_annotations)

## convert _ to -
gene_annotations$Gene.ID <- gsub("_", "-", gene_annotations$Gene.ID)
```

# 3. Monocle on sex cells {.tabset}

## calculate pseudotime and modules

#### Preparation
```{r}
## extracts only 10x cells and also remove cluster 0 cells 
wt_cells <- rownames(tenx.justwt.integrated.sex@meta.data[which(tenx.justwt.integrated.sex@meta.data$identity_name_combined == "WT_10X" & !tenx.justwt.integrated.sex@meta.data$seurat_clusters == "3"),])

# & !tenx.justwt.integrated.sex@meta.data$seurat_clusters == "6"

## make a new Seurat of this
seurat.object <-subset(tenx.justwt.integrated.sex, cells = wt_cells)

## check that this is the same as the pb_sex_filtered object
#data_test <- as(as.matrix(GetAssayData(pb_sex_filtered, assay = "RNA", slot = "data")), 'sparseMatrix')
#is.equal
#is.identical

## extract counts and pheno:
## the reason we use the integrated and then subsetted is because these cells have been normalised whereas the cells in pb_sex_filtered have not been normalised (well they have but with doublets in them)
## with 10x only cells: all.equal(as.data.frame(counts(monocle.object)), as.data.frame(as.matrix(GetAssayData(seurat.object, assay = "RNA", slot = "counts")))) returns TRUE and also returns true when you change the slot input to "counts" and use monocle to norm it with method "log"
data <- as(as.matrix(GetAssayData(seurat.object, assay = "RNA", slot = "counts")), 'sparseMatrix')
## make phenodata
pd <- data.frame(seurat.object@meta.data)
## keep only the columns that are relevant in metadata
#pData <- pd %>% select(orig.ident, nCount_RNA, nFeature_RNA)
## make gene metadata
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

## Construct monocle cds
monocle.object <- new_cell_data_set(expression_data = data, cell_metadata = pd, gene_metadata = fData)

## preprocess
monocle.object = preprocess_cds(monocle.object, num_dim = 50, norm_method = "log")
### if using integrated data:
# norm_method = "none", alignment_group = "~ experiment"

## plot jack straw plot
#plot_pc_variance_explained(monocle.object)

#monocle.object = reduce_dimension(monocle.object, reduction_method = "UMAP", preprocess_method = "PCA", umap.metric = "euclidean", umap.n_neighbors = 50, umap.min_dist = 0.5, verbose = FALSE)

#plot_cells(monocle.object, color_cells_by="experiment")

## graph learning

## add UMAP from Seurat
monocle.object@int_colData@listData$reducedDims@listData[["UMAP"]] <- seurat.object@reductions[["umap"]]@cell.embeddings
## if you want the old UMAP from the original all cells one, use: "DIM_UMAP"

## cluster
## this is essential to run the learn_graph function later on
monocle.object = cluster_cells(monocle.object)

## plot initial clustering by monocle
#plot_cells(monocle.object, color_cells_by="cluster", group_cells_by="partition", x = 2, y = 1)

## map pseudotime
monocle.object = learn_graph(monocle.object, learn_graph_control=list(ncenter=550, minimal_branch_len = 30), use_partition = FALSE)
# learn_graph_control=list(ncenter=500) - play with this parameter - lower tends to give fewer branches and higher tends to give more
# 500 - old analysis
# 250 - new analysis 

## Plot cells
plot_cells(monocle.object, color_cells_by="monocle_sex", group_cells_by="partition", x = 1, y = 2)
```

Redefine the identities of the male and female cells 

male
```{r}
# monocle.object_male <- choose_graph_segments(monocle.object)
```
female
```{r}
# monocle.object_female <- choose_graph_segments(monocle.object)
```
bipotential
```{r}
#monocle.object_bipot <- choose_graph_segments(monocle.object)
```
asexual
```{r}
#monocle.object_asex <- choose_graph_segments(monocle.object)
```
asexual fate
```{r}
#monocle.object_asex_fate <- choose_graph_segments(monocle.object)
```

check
```{r}
# df_freq <- data.frame(table(c(colnames(monocle.object_male), colnames(monocle.object_female), colnames(monocle.object_bipot), colnames(monocle.object_asex), colnames(monocle.object_asex_fate))))
# paste("number of cells in seurat object is", length(colnames(monocle.object)), ". The number of cells selected here with an identitity is", dim(df_freq)[1])
# df_freq <- df_freq[df_freq$Freq > 1, ]
# df_freq
```
Inspect where these missing cells are:
```{r}
# '%ni%' <- Negate('%in%')
# 
# not_assigned_cells <- colnames(monocle.object)[colnames(monocle.object) %ni% c(colnames(monocle.object_male), colnames(monocle.object_female), colnames(monocle.object_bipot), colnames(monocle.object_asex), colnames(monocle.object_asex_fate))]
# 
# DimPlot(seurat.object, repel = TRUE, label.size = 5, pt.size = 0.5, cells.highlight = not_assigned_cells, dims = c(2,1), reduction = "DIM_UMAP") +
#   coord_fixed() + 
#   scale_color_manual(values=c("#000000", "#f54e1e"))
```

```{r}
# ## create annotation dataframe from these results:
# df_monocle_sexes <- rbind(data.frame("cell_name" = colnames(monocle.object_male), "sex" = rep("Male", length(colnames(monocle.object_male)))),
#                           data.frame("cell_name" = colnames(monocle.object_female), "sex" = rep("Female", length(colnames(monocle.object_female)))),
#                           data.frame("cell_name" = colnames(monocle.object_bipot), "sex" = rep("Bipotential", length(colnames(monocle.object_bipot)))),
#                           data.frame("cell_name" = colnames(monocle.object_asex), "sex" = rep("Asexual", length(colnames(monocle.object_asex)))),
#                           data.frame("cell_name" = colnames(monocle.object_asex_fate), "sex" = rep("Asexual_Fate", length(colnames(monocle.object_asex_fate)))),
#                           data.frame("cell_name" = not_assigned_cells, "sex" = rep("Unassigned", length(not_assigned_cells)))
#                           )
# 
# dim(df_monocle_sexes)
# 
# ## order like the metadata
# df_monocle_sexes <- df_monocle_sexes[match(rownames(monocle.object@colData), df_monocle_sexes$cell_name), ]
# 
# ## add this back into the monocle object
# monocle.object@colData$Sexes_monocle <- df_monocle_sexes$sex
```

#### Pseudotime Calculation
```{r}
## Order the cells and calculate pseudotime
monocle.object = order_cells(monocle.object)

## Plot
umap_pt <- plot_cells(monocle.object, color_cells_by = "pseudotime", label_cell_groups=FALSE, cell_size = 1, x = 1, y = 2, label_branch_points=FALSE, label_leaves=FALSE, label_groups_by_cluster=FALSE, label_roots = FALSE) +
  coord_fixed() +
  theme_void() +
  labs(title = "Pseudotime") +
  theme(plot.title = element_text(hjust = 0.5, size=15), legend.position="bottom", legend.title=element_text (size=10), legend.text=element_text(size=10)) + 
  guides(colour = guide_colourbar(barwidth = 10, barheight = 0.5, title = "Pseudotime"))

## view
umap_pt
```

#### Check how well it correlates with the original pseudotime

when pseudotime was calculated on the whole object

```{r}
library(ggpubr)
## extract pseudotime values:
pt_values_new <- as.data.frame(pseudotime(monocle.object, reduction_method = "UMAP"))
pt_values_new$cell_name <- rownames(pt_values_new)
meta_data_df <- as.data.frame(monocle.object@colData)
meta_data_df$cell_name <- rownames(meta_data_df)
meta_data_df <- merge(meta_data_df, pt_values_new, by = "cell_name")
names(meta_data_df)[ncol(meta_data_df)]<- "pt"

ggplot(meta_data_df, aes(x = old_pt_values, y = pt, colour = monocle_sex)) + 
  geom_point() +  
  geom_smooth(method = "lm", se = FALSE) +
  theme_classic() + stat_cor(method = "pearson")
```

#### Module Construction
```{r}
## find genes that change as a function of pt:
monocle.object_pr_test_res <- graph_test(monocle.object, neighbor_graph="principal_graph", cores=8, expression_family = "negbinomial")
# explains expression family - https://cole-trapnell-lab.github.io/monocle3/docs/differential/ - results were same for either defauly or negbinomial

## find significant genes
## I used 0.05 previously in all cells 
## 2884 w. p = 0.01, 3260 w. p = 0.05
pr_deg_ids <- row.names(subset(monocle.object_pr_test_res, q_value < 0.05))

## collect into modules
gene_module_df_sex <- find_gene_modules(monocle.object[pr_deg_ids,], resolution=c(10^seq(-6,2)), random_seed = 1234)

## how many genes in modules?
dim(gene_module_df_sex)
```

```{r, echo = FALSE}
paste("there are", length(levels(gene_module_df_sex$module)), "modules")
```

## Plot Modules

#### General Module Composition

Make a dataframe to plot by aggregating clusters vs. modules
```{r}
## make cell group df
cell_group_df <- tibble::tibble(cell=row.names(colData(monocle.object)), cell_group=colData(monocle.object)$seurat_clusters)

## make plotting df
#agg_mat <- aggregate_gene_expression(monocle.object, gene_module_df_sex, cell_group_df)
```

Find out how many genes there are per total so we can add this to the plot
```{r}
## how many genes per module?
genes_per_module <- as.data.frame(table(gene_module_df_sex$module))
genes_per_module
```

Find out which modules our mutant genes reside in
```{r}
## create a list of our mutant gene IDs
list_of_mutant_genes <- c("PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")

## make a dataframe to convert the gene IDs into actual IDs
ss2_mutants_final <- readRDS("../data_to_export/ss2_mutants_final.RDS")
df_mutant_ids <- as.data.frame(unique(cbind(ss2_mutants_final@meta.data$identity_gene_updated, ss2_mutants_final@meta.data$identity_updated, ss2_mutants_final@meta.data$identity_name_updated)))[-c(2),]
rm(ss2_mutants_final)
# remove the "820" bit on 10
df_mutant_ids$V1 <- gsub("_820", "", df_mutant_ids$V1)
# change the underscore (_) to a dash (-) in gene IDs
df_mutant_ids$V1 <- gsub("_", "-", df_mutant_ids$V1)
names(df_mutant_ids) <- c("gene_ID", "mutant_identity", "mutant_identity_2")

## subset modules df to include only mutant gene IDs
df_mutant_gene_modules <- as.data.frame(gene_module_df_sex[which(gene_module_df_sex$id %in% list_of_mutant_genes),])
names(df_mutant_gene_modules)[1] <- "gene_ID"

## merge dataframes
df_mutant_gene_modules <- merge(df_mutant_gene_modules, df_mutant_ids, by = "gene_ID")

## Inspect
df_mutant_gene_modules[order(df_mutant_gene_modules$module), ]
```

so modules of interest are:
```{r}
table(df_mutant_gene_modules$module)
```

Which modules do other genes of interest lie in?:
```{r}
## landmark genes (genes of interest)
# AP2G - PBANKA-1437500
# AP2 - PBANKA-0909600 - from poran paper
# AP2G-2 - PBANKA-1034300 
# ccp2 - "PBANKA-1319500" - female 820
# p25 - "PBANKA-0515000" - female
# p28 - "PBANKA-0514900" - female
# ccp3 - "PBANKA-1035200" - female -  https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5909122/
# nek4 - "PBANKA-0616700" - female
# ap2-fg - "PBANKA-1415700" - female 
# dozi - "PBANKA-1217700" - female
# MG1 - "PBANKA-0416100" - male 820
# hap2 - "PBANKA-1212600" - male
# MAPK2 - "PBANKA-0933700" - male
# nek1 - "PBANKA-1443000" - male
# cdpk4 - "PBANKA-0615200" - male

## create a list of landmark genes
list_of_landmark_genes <- c("PBANKA-1437500",
                            "PBANKA-0909600",
                            "PBANKA-1034300", 
                            "PBANKA-1319500", 
                            "PBANKA-0515000",
                            "PBANKA-0514900",
                            "PBANKA-1035200",
                            "PBANKA-0616700",
                            "PBANKA-1415700",
                            "PBANKA-1217700",
                            "PBANKA-0416100", 
                            "PBANKA-1212600",
                            "PBANKA-0933700",
                            "PBANKA-1443000",
                            "PBANKA-0615200")

name_of_landmark_genes <- c("AP2-G", 
                            "AP2_poran", 
                            "AP2-G2", 
                            "ccp2", 
                            "p25", 
                            "p28",
                            "ccp3",
                            "nek4",
                            "ap2-fg",
                            "DOZI",
                            "mg1", 
                            "hap2", 
                            "mapk2",
                            "nek1",
                            "cdpk4")

## make a df
name_of_landmark_genes <- data.frame("gene_name" = name_of_landmark_genes, "id" = list_of_landmark_genes)

## make dataframe
df_landmark_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% list_of_landmark_genes),]

## merge dataframes
df_landmark_gene_modules <- merge(df_landmark_gene_modules, name_of_landmark_genes, by = "id")

## inspect
df_landmark_gene_modules[order(df_landmark_gene_modules$module), ]
```

#### enrichment of screen hits in modules
```{r}
## read in screen hits
library("readxl")
screen_hits <- read_excel("../data/Screen/Modules_Clusters_Phenotypes.xlsx")

## get only hits
screen_hits_selected <- screen_hits[which(screen_hits$`Gam phenotype screen` == "Both" | screen_hits$`Gam phenotype screen` == "Females" | screen_hits$`Gam phenotype screen` == "Males"), ] 

## extract gene IDs
gene_hits <- screen_hits_selected$`new gene ID`
## change the underscore to a dash
gene_hits <- gsub("_", "-", gene_hits)

## find out which modules they are in
df_hits_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% gene_hits),]
print("screen hits by module")
table(df_hits_gene_modules$module)

## get the number genes screened in that module
screen_hits_screened <- screen_hits[which(screen_hits$`Gam phenotype screen` == "Both" | screen_hits$`Gam phenotype screen` == "Females" | screen_hits$`Gam phenotype screen` == "Males" | screen_hits$`Gam phenotype screen` == "None" | screen_hits$`Gam phenotype screen` == "male not enough power"), ] 
## extract gene IDs
genes_screened <- screen_hits_screened$`new gene ID`
## change the underscore to a dash
genes_screened <- gsub("_", "-", genes_screened)
## find out which modules they are in
df_screened_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% genes_screened),]
print("total genes screened in this module")
table(df_screened_gene_modules$module)

## make a table with this info
pc_screened <- data.frame(hits = table(df_hits_gene_modules$module), screened =  table(df_screened_gene_modules$module))[,-3]
names(pc_screened) <- c("module", "hits", "screened")
pc_screened$pc <- (pc_screened$hits /pc_screened$screened)*100

## view
pc_screened
```
Further investigation of screen hits
```{r}
## rename df
df_screen_hits_selected <- as.data.frame(screen_hits_selected)
df_screen_hits_selected$'new gene ID' <- gsub("_", "-", df_screen_hits_selected$'new gene ID')
names(df_screen_hits_selected)[2] <- "id"
df_gene_module_df_sex <- as.data.frame(gene_module_df_sex)

## merge dfs together
screen_hits_modules <- merge(df_screen_hits_selected, df_gene_module_df_sex, by = "id")

## view
screen_hits_modules
```

```{r}
## change the row order to match the heatmap later
pc_screened$module <- factor(pc_screened$module, levels = rev(c("10", "9", "17", "4", "2", "6", "12", "14",
               "21", "7", 
               "22", "23","13","16", "18", "19", "11", "15", "5",
               "20", "8", "3", "1"
               )))

 h1 <- ggplot(data = pc_screened, mapping = aes(x = module, fill=pc)) +
  geom_bar(col = "#FFFFFF", width = 1)+
      theme_void() +
    theme(panel.spacing.x = unit(1, "mm")) +
    scale_fill_continuous_sequential(palette = "Greens") +
  coord_flip()
 legend <- get_legend(h1)
 h1 <- h1 + theme(legend.position = "none")

 
screen_annotation <- plot_grid(h1, legend, nrow = 1, rel_widths = c(10, 1.5))
screen_annotation
```

```{r}
ggsave("../images_to_export/screen_annotation.png", plot = screen_annotation, device = "png", path = NULL, scale = 1, width = 10, height = 10, units = "cm", dpi = 300, limitsize = TRUE)
```

#### DOZI-regulated genes

Find out how many of the genes in each module has a DOZI-regulated gene

```{r}
DOZI_regulated_genes <-
read.csv(file = "../data/Reference/DOZI_regulated_genes.csv", header = TRUE)

## extract gene IDs
dozi_genes <- DOZI_regulated_genes[DOZI_regulated_genes$DOZI_regulated. == "YES", ]$Gene_ID_PB
## change the underscore to a dash
dozi_genes <- gsub("_", "-", dozi_genes)

## find out which modules they are in
df_dozi_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% dozi_genes),]
print("dozi genes by module")
table(df_dozi_gene_modules$module)
```
get as a percentage
```{r}
## make a table with the total number of genes in each module
test <- as.data.frame(table(gene_module_df_sex$module), stringsAsFactors=FALSE)
## reorder rows by module number
test <- test[order(as.numeric(test$Var1)),]
## combine the total number of dozi genes per module with the total number of genes per module
pc_screened <- data.frame(dozi = table(df_dozi_gene_modules$module), total =  test)[,-3]
names(pc_screened) <- c("module", "dozi_genes_per_module", "total_genes_per_module")
## calculate percentage
pc_screened$pc <- (pc_screened$dozi_genes_per_module /pc_screened$total_genes_per_module)*100

## view
pc_screened
```

```{r}
## change row order:
row.order <- c("10", "9", "17", "4", "2", "6", "12", "14",
               "21", "7", 
               "22", "23","13","16", "18", "19", "11", "15", "5",
               "20", "8", "3", "1"
               )
## change the module to a string
#pc_screened$module <- as.numeric(as.character(pc_screened$module))
#pc_screened$module <- as.factor(pc_screened$module)
#pc_screened <- pc_screened[match(row.order, pc_screened$module), ]
pc_screened$module <- factor(pc_screened$module, levels = rev(c("10", "9", "17", "4", "2", "6", "12", "14",
               "21", "7", 
               "22", "23","13","16", "18", "19", "11", "15", "5",
               "20", "8", "3", "1"
               )))

 h1 <- ggplot(data = pc_screened, mapping = aes(x = module, fill=pc)) +
  geom_bar(col = "#FFFFFF", width = 1)+
      theme_void() +
    theme(panel.spacing.x = unit(1, "mm")) +
    scale_fill_continuous_sequential(palette = "Blues") +
  coord_flip()
 legend <- get_legend(h1)
 h1 <- h1 + theme(legend.position = "none")

 
dozi_annotation <- plot_grid(h1, legend, nrow = 1, rel_widths = c(10, 1.5))
dozi_annotation
```

```{r}
ggsave("../images_to_export/dozi_annotation.png", plot = dozi_annotation, device = "png", path = NULL, scale = 1, width = 10, height = 10, units = "cm", dpi = 300, limitsize = TRUE)
```

#### Essential genes

Find out how many of the genes in each module has a DOZI-regulated gene

```{r}
essential_genes <-
read.csv(file = "../data/Reference/bushell_2017_data.csv", header = TRUE)

## extract info
essential_genes <- essential_genes[, c("P..berghei.current.ID", "Phenotype" )]
names(essential_genes) <- c("id", "phenotype")
## change the underscore to a dash
essential_genes$id <- gsub("_", "-", essential_genes$id)
## remove any transcript numbers
essential_genes$id <- sub("\\..*", "", essential_genes$id)

## find out which modules all screened genes are in
df_screened_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% essential_genes$id),]
print("total genes screened in this module")
table(df_screened_gene_modules$module)

## extract 3 main phenotypes - there are only two fast genes, and 13 Insufficient data
e_genes <- essential_genes[essential_genes$phenotype == "Essential", ]$id
s_genes <- essential_genes[essential_genes$phenotype == "Slow", ]$id
d_genes <- essential_genes[essential_genes$phenotype == "Dispensable", ]$id

## find out which modules they are in
e_genes_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% e_genes),]
print("essential genes by module")
table(e_genes_gene_modules$module)
s_genes_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% s_genes),]
print("slow genes by module")
table(s_genes_gene_modules$module)
d_genes_gene_modules <- gene_module_df_sex[which(gene_module_df_sex$id %in% d_genes),]
print("dispensible genes by module")
table(d_genes_gene_modules$module)

## make a combined table with this info
pc_screened <- data.frame(essential = table(e_genes_gene_modules$module), 
                          slow = table(s_genes_gene_modules$module),
                          dispensible = table(d_genes_gene_modules$module), 
                          screened =  table(df_screened_gene_modules$module))[,-c(3, 5, 7)]
names(pc_screened) <- c("module", "essential", "slow", "dispensible", "screened")
pc_screened$pc_e <- (pc_screened$essential /pc_screened$screened)*100
pc_screened$pc_s <- (pc_screened$slow /pc_screened$screened)*100
pc_screened$pc_d <- (pc_screened$dispensible /pc_screened$screened)*100

```

```{r}
## change row order:
row.order <- c("10", "9", "17", "4", "2", "6", "12", "14",
               "21", "7", 
               "22", "23","13","16", "18", "19", "11", "15", "5",
               "20", "8", "3", "1"
               )
## change the module to a string
#pc_screened$module <- as.numeric(as.character(pc_screened$module))
#pc_screened$module <- as.factor(pc_screened$module)
#pc_screened <- pc_screened[match(row.order, pc_screened$module), ]
pc_screened$module <- factor(pc_screened$module, levels = rev(c("10", "9", "17", "4", "2", "6", "12", "14",
               "21", "7", 
               "22", "23","13","16", "18", "19", "11", "15", "5",
               "20", "8", "3", "1"
               )))

library(scales) # For the percent_format() function

 h1 <- ggplot(data = pc_screened, mapping = aes(x = module, fill=pc_e)) +
  geom_bar(col = "#FFFFFF", width = 1)+
      theme_void() +
    theme(panel.spacing.x = unit(1, "mm")) +
    scale_fill_continuous_sequential(palette = "Reds", labels = percent_format(scale = 1), limits=c(0,100)) +
  coord_flip()
 legend <- get_legend(h1)
 h1 <- h1 + theme(legend.position = "none")
 
  h2 <- ggplot(data = pc_screened, mapping = aes(x = module, fill=pc_s)) +
  geom_bar(col = "#FFFFFF", width = 1)+
      theme_void() +
    theme(panel.spacing.x = unit(1, "mm")) +
    scale_fill_continuous_sequential(palette = "Reds", labels = percent_format(scale = 1), limits=c(0,100)) +
  coord_flip()
 legend_2 <- get_legend(h2)
 h2 <- h2 + theme(legend.position = "none")
 
  h3 <- ggplot(data = pc_screened, mapping = aes(x = module, fill=pc_d)) +
  geom_bar(col = "#FFFFFF", width = 1)+
      theme_void() +
    theme(panel.spacing.x = unit(1, "mm")) +
    scale_fill_continuous_sequential(palette = "Reds", labels = percent_format(scale = 1), limits=c(0,100)) +
  coord_flip()
 legend_3 <- get_legend(h3 + theme(legend.position = "bottom", legend.box.margin = margin(0, 0, 0, 12)))
 h3 <- h3 + theme(legend.position = "none")
 
 ## add some space to the left of the legend as: https://wilkelab.org/cowplot/articles/shared_legends.html
#legend <- legend + theme(legend.box.margin = margin(0, 0, 0, 12))
 
 
bloodstage_annotation <- plot_grid(h1,h2,h3, nrow = 1, rel_widths = c(1,1,1))
bloodstage_annotation <- plot_grid(bloodstage_annotation,legend_3, nrow = 2, rel_heights = c(3,1))
bloodstage_annotation
```

```{r}
ggsave("../images_to_export/bloodstage_annotation.png", plot = bloodstage_annotation, device = "png", path = NULL, scale = 1, width = 10, height = 10, units = "cm", dpi = 300, limitsize = TRUE)
```

#### Visualise module expression

plot out modules
```{r, fig.height = 7, fig.width = 7}
## make aggregated df again so you can edit it
agg_mat <- aggregate_gene_expression(monocle.object, gene_module_df_sex, cell_group_df)

## h clust the aggregated matrix
module_dendro <- hclust(dist(agg_mat))

## use these clusters to reorder the modules
gene_module_df_sex$module <- factor(gene_module_df_sex$module, levels = row.names(agg_mat)[module_dendro$order])

## plot
UMAP_modules <- plot_cells(monocle.object, genes=gene_module_df_sex %>% filter(module %in% c(1:length(levels(gene_module_df_sex$module)))),
           cell_size = 2, 
           x = 1, y = 2,
           label_cell_groups=FALSE,
           scale_to_range = TRUE,
           show_trajectory_graph=FALSE) +
                          scale_colour_viridis_c(name = "expression", option = "C", alpha = 1) +
                          coord_fixed() +
                          theme_void() +
                          theme(legend.position = "bottom", strip.text.x = element_text(size = 15))

## view
UMAP_modules
```
save
```{r}
#ggsave("../images_to_export/GCSKO_sexbranch_umap_modules.png", plot = UMAP_modules, device = "png", path = NULL, scale = 1, width = 30, height = 30, units = "cm", dpi = 300, limitsize = TRUE)
```

```{r}
## make a dataframe of genes per module
genes_per_module <- as.data.frame(table(gene_module_df_sex$module))

## inspect
genes_per_module
```

```{r, fig.height = 8, fig.width = 12}
## A. Preparation of dataframe

## prepare custom dataframe for all cells by modules:
agg_mat_no_group <- aggregate_gene_expression(monocle.object, gene_module_df_sex, scale_agg_values = TRUE)

## B. annotations

## make an anotation
## add pt to the monocle object
monocle.object@colData$pt_sex <- as.data.frame(pseudotime(monocle.object, reduction_method = "UMAP"))[,1]
## make an annotation dataframe
anno_no_group <- data.frame(monocle.object@colData$monocle_sex, monocle.object@colData$pt_sex, as.factor(monocle.object@colData$Prediction.Spearman._Kasia), row.names = rownames(monocle.object@colData))
names(anno_no_group) <- c("Sex", "Pseudotime", "Real_time_prediction")

## make annotation colours
annotation_colours <- list(Sex = c(Male="#016c00", Female="#a52b1e", Bipotential = "#ffe400", Asexual_Early = "#0052c5"),
                           Pseudotime = plasma(12, direction = 1),
                           Real_time_prediction = c("0" = viridis(8, direction = 1)[1] ,"1" =  viridis(8, direction = 1)[2] ,"4" = viridis(8, direction = 1)[3] ,"6" = viridis(8, direction = 1)[4] ,"8" = viridis(8, direction = 1)[5]  ,"12"  = viridis(8, direction = 1)[6]  ,"18" = viridis(8, direction = 1)[7]  ,"24" = viridis(8, direction = 1)[8]))

## change the order of the cols (cells) in data frame
col.order <- rownames(anno_no_group[with(anno_no_group, order(Sex, Pseudotime)), ])
agg_mat_no_group <- agg_mat_no_group[,col.order]

## reorder the rows (gene modules) in the data frame so they are in pt order
## define the order visually and using the clusters originally produced
row.order <- c("10", "9", "17", "4", "2", "6", "12", "14",
               "21", "7", 
               "22", "23","13","16", "18", "19", "11", "15", "5",
               "20", "8", "3", "1"
               )
## reorder using new order
agg_mat_no_group <- agg_mat_no_group[row.order, ]

## for cuts in columns - used later to count number of cells in each cat
df_meta <- as.data.frame(monocle.object@colData)
female_cells <- rownames(df_meta[which(df_meta$monocle_sex == "Female"), ])
male_cells <- rownames(df_meta[which(df_meta$monocle_sex == "Male"), ])
bi_cells <- rownames(df_meta[which(df_meta$monocle_sex == "Bipotential"), ])
asex_cells <- rownames(df_meta[which(df_meta$monocle_sex == "Asexual_Early"), ])
rm(df_meta)

## add module and the number of cells to the row
## change names for row names to include "module " at the begining of them
labels.row <- stringr::str_c("Module ", row.names(agg_mat_no_group))
## reorder frequency so that it is matching our matrix
genes_per_module_ordered <- genes_per_module[match(row.names(agg_mat_no_group), genes_per_module$Var1), ]
## add number of cells to the rownames for the module
for(i in seq_along(genes_per_module_ordered$Freq)){
  labels.row[i] <- stringr::str_c(labels.row[i]," (n = " ,genes_per_module_ordered$Freq[i], ")")
}

## C. Plotting

## plot
heatmap_main <- pheatmap::pheatmap(agg_mat_no_group,
                                   #scale="row",
                                   #color = diverging_hcl(100, palette = "Blue-Red 3"),
                                   cluster_cols = FALSE,
                                   cluster_rows = FALSE,
                                   ## others: ward.D2,
                                   #clustering_method="complete",
                                   scale = "none",
                                   show_colnames = FALSE,
                                   labels_row = labels.row,
                                   fontsize_row = 15,
                                   fontsize = 12,
                                   gaps_col = c(length(asex_cells), length(c(asex_cells,bi_cells)), length(c(asex_cells,bi_cells,female_cells))),
                                   annotation_col = anno_no_group, 
                                   annotation_colors = annotation_colours, 
                                   cutree_rows = 6
                                   )

## view
heatmap_main
```
save
```{r}
ggsave("../images_to_export/GCSKO_sexbranch_heatmap.png", plot = heatmap_main, device = "png", path = NULL, scale = 1, width = 21, height = 21, units = "cm", dpi = 300, limitsize = TRUE)
```

#### Visualise the expression of select genes over pseudotime

```{r, fig.height = 8, fig.width = 10}
## landmark genes (genes of interest)
# AP2G - PBANKA-1437500
# AP2 - PBANKA-0909600 - from poran paper
# AP2G-2 - PBANKA-1034300 
#list_of_mutant_genes <- c("PBANKA-0828000", "PBANKA-1302700", "PBANKA-1447900", "PBANKA-0102400", "PBANKA-0716500", "PBANKA-1435200", "PBANKA-1418100", "PBANKA-1144800", "PBANKA-0902300", "PBANKA-0413400", "PBANKA-1454800")

## define genes to plot
list_of_genes_of_interest <- c("PBANKA-0102400", "PBANKA-0413400", "PBANKA-0716500", "PBANKA-0828000", "PBANKA-0902300", "PBANKA-1144800", "PBANKA-1302700", "PBANKA-1418100", "PBANKA-1435200", "PBANKA-1447900", "PBANKA-1454800", "PBANKA-1437500", "PBANKA-1319500", "PBANKA-0416100", "PBANKA-1034300")
## add names
names_of_genes_of_interest <- c("GCSKO-2", "GCSKO-10", "GCSKO-19", "GCSKO-3", "GCSKO-13", "GCSKO-28", "GCSKO-oom", "GCSKO-17", "GCSKO-20", "GCSKO-29", "GCSKO-21", "AP2-G", "CCP2", "MG1", "AP2-G2")

##make df for genes of interest
genes_of_interest <- data.frame(gene = list_of_genes_of_interest, group = c(1:length(list_of_genes_of_interest)), name = names_of_genes_of_interest)
## reorder
#genes_of_interest <- genes_of_interest[match(c("AP2-G", "CCP2", "GCSKO-21", "GCSKO-17", "GCSKO-2", "MG1", "GCSKO-20", "GCSKO-3", "GCSKO-oom", "GCSKO-29", "GCSKO-10", "GCSKO-28", "GCSKO-19", "GCSKO-13"), genes_of_interest$name), ]

## prepare custom dataframe for all cells by modules:
agg_mat_genes_of_interest <- aggregate_gene_expression(monocle.object, genes_of_interest[,1:2], scale_agg_values = FALSE)

## reorder using new order
agg_mat_genes_of_interest <- agg_mat_genes_of_interest[,col.order]

## plot
heatmap_plot <- pheatmap::pheatmap(agg_mat_genes_of_interest, 
                   #scale="row",
                   cluster_cols = FALSE,
                   cluster_rows = TRUE,
                   clustering_method="ward.D2",
                   show_colnames = FALSE,
                   labels_row = as.character(genes_of_interest[,3]),
                   gaps_col = c(length(asex_cells), length(c(asex_cells,bi_cells)), length(c(asex_cells,bi_cells,female_cells))),
                   #gaps_row = c(1, 6),
                   cutree_rows = 3,
                   ## trying to fix legend issue here
                   #fontsize_row = 10,
                   #fontsize_col = 3,
                   #cellheight=3, 
                   #cellwidth = 3,
                   legend = TRUE,
                   annotation_legend = FALSE,
                   annotation_col = anno_no_group, 
                   annotation_colors = annotation_colours
                   )

heatmap_plot
```

investigate specific modules
```{r}
## rename df
df_screen_hits_selected_module <- as.data.frame(gene_module_df_sex[gene_module_df_sex$module == "20", ])

## merge dfs together
module_20_annotated <- merge(gene_annotations, df_screen_hits_selected_module,by.x = "Gene.ID", by.y = "id")

## view
View(module_20_annotated)

## annotate all modules
gene_module_df_sex_annotated <- merge(gene_annotations, gene_module_df_sex, by.x = "Gene.ID", by.y = "id")
View(gene_module_df_sex_annotated)
```

# 4. Mapping on mutants {.tabset}

pca plots
```{r}
DimPlot(tenx.justwt.integrated.sex, reduction = 'pca', group.by = 'monocle_sex')
```


Seurat method

```{r}
pancreas.anchors <- FindTransferAnchors(reference = seurat.object, query = SMARTSEQ, 
    dims = 1:30)
predictions <- TransferData(anchorset = pancreas.anchors, refdata = seurat.object$monocle_sex, 
    dims = 1:30)
pancreas.query <- AddMetaData(pancreas.query, metadata = predictions)
```




# Final Figures

```{r}
## C
## This shows the cells selected for module analysis 
## this package allows easy extraction of viridis values used in the pt plots
library("colourvalues") # allows 
## extract colour hex values 
monocle.object@colData$pt_sex_col <- colour_values(monocle.object@colData$pt_sex, palette = "plasma")

## load in the whole dataset if you haven't already loaded it in
#tenx.justwt.integrated <- readRDS("../data_to_export/tenx.justwt.integrated.RDS")

## extract metadata
df_plot <- tenx.justwt.integrated@meta.data

## add umap - merge on row names and then make sure row names are not dropped or added
df_plot <- transform(merge(df_plot, tenx.justwt.integrated@reductions[["umap"]]@cell.embeddings, by=0, all=TRUE), row.names=Row.names, Row.names=NULL)

## make new col for colours - and make everything grey
df_plot$hex <- "#e7e7e7"

## extract colours for highlighted cells 
df_plot_2 <- as.data.frame(monocle.object@colData[,"pt_sex_col", drop = FALSE])

## then merge this back into the colour column, whilst matching the rows
rownames_to_match <- rownames(df_plot[rownames(df_plot) %in% rownames(df_plot_2), ])

df_plot$hex[rownames(df_plot) %in% rownames(df_plot_2)] <- df_plot_2[match(rownames_to_match, rownames(df_plot_2)), , drop = FALSE][ ,1]

### make character so ggplto2 recognises them
df_plot$hex <- as.character(df_plot$hex)

## reorder so that the voloured points are on top
## this is a bit hacky but you can split the data frame and then remerge, since the command commented out will still put E above other values - this command was just order by the col hex
df_plot_1 <- df_plot[!(df_plot$hex == "#e7e7e7"), ]
df_plot_2 <- df_plot[(df_plot$hex == "#e7e7e7"), ]
df_plot <- rbind(df_plot_2, df_plot_1)
rm(df_plot_2, df_plot_1)

## add tree
##The tree for monocle is located here:
# monocle.object@principal_graph_aux[["UMAP"]]$dp_mst 
ica_space_df <- t(monocle.object@principal_graph_aux[["UMAP"]]$dp_mst) %>%
      as.data.frame() %>%
      dplyr::select_(prin_graph_dim_1 = "UMAP_1", prin_graph_dim_2 = "UMAP_2") %>%
      dplyr::mutate(sample_name = rownames(.),
                    sample_state = rownames(.))

dp_mst <- monocle.object@principal_graph[["UMAP"]]

edge_df <- dp_mst %>%
      igraph::as_data_frame() %>%
      dplyr::select_(source = "from", target = "to") %>%
      dplyr::left_join(ica_space_df %>%
                         dplyr::select_(
                           source="sample_name",
                           source_prin_graph_dim_1="prin_graph_dim_1",
                           source_prin_graph_dim_2="prin_graph_dim_2"),
                       by = "source") %>%
      dplyr::left_join(ica_space_df %>%
                         dplyr::select_(
                           target="sample_name",
                           target_prin_graph_dim_1="prin_graph_dim_1",
                           target_prin_graph_dim_2="prin_graph_dim_2"),
                       by = "target")


umap_zoom_plot <- ggplot(df_plot, aes(x = UMAP_1, y = UMAP_2, colour = hex)) +
                         geom_point(size = 2) +
                        ## need this to tell ggplot2 to map to values
                         scale_colour_identity() +
                        ## fix coordinates
                         coord_fixed() +
                         theme_void() + 
                         theme(legend.position = "none") +
                         geom_segment(aes_string(x="source_prin_graph_dim_1",
                                                 y="source_prin_graph_dim_2",
                                                 xend="target_prin_graph_dim_1",
                                                 yend="target_prin_graph_dim_2"
                                                 ),
                                      data=edge_df, inherit.aes = FALSE
                                      )
  
  
umap_zoom_plot

## remove big dataset
#rm(tenx.justwt.integrated)
```

```{r}
# Extract the legend. Returns a gtable
leg <- get_legend(umap_pt)

# Convert to a ggplot and print
legend_d <- as_ggplot(leg)

legend_d
```

save
```{r}
ggsave("../images_to_export/Figure_D.png", plot = umap_zoom_plot, device = "png", path = NULL, scale = 1, width = 21, height = 29.7, units = "cm", dpi = 300, limitsize = TRUE)
ggsave("../images_to_export/Figure_D_legend.png", plot = legend_d, device = "png", path = NULL, scale = 1, width = 21, height = 29.7, units = "cm", dpi = 300, limitsize = TRUE)
```

```{r}
## C
## This shows the cells selected for module analysis 
## this package allows easy extraction of viridis values used in the pt plots
library("colourvalues") # allows 
## extract colour hex values 
monocle.object@colData$rt_sex_col <- colour_values(monocle.object@colData$Prediction.Spearman., palette = "viridis")

## load in the whole dataset if you haven't already loaded it in
#tenx.justwt.integrated <- readRDS("../data_to_export/tenx.justwt.integrated.RDS")

## extract metadata
df_plot <- tenx.justwt.integrated@meta.data

## add umap - merge on row names and then make sure row names are not dropped or added
df_plot <- transform(merge(df_plot, tenx.justwt.integrated@reductions[["umap"]]@cell.embeddings, by=0, all=TRUE), row.names=Row.names, Row.names=NULL)

## make new col for colours - and make everything grey
df_plot$hex <- "#e7e7e7"

## extract colours for highlighted cells 
df_plot_2 <- as.data.frame(monocle.object@colData[,"rt_sex_col", drop = FALSE])

## then merge this back into the colour column, whilst matching the rows
rownames_to_match <- rownames(df_plot[rownames(df_plot) %in% rownames(df_plot_2), ])

df_plot$hex[rownames(df_plot) %in% rownames(df_plot_2)] <- df_plot_2[match(rownames_to_match, rownames(df_plot_2)), , drop = FALSE][ ,1]

### make character so ggplto2 recognises them
df_plot$hex <- as.character(df_plot$hex)

## reorder so that the voloured points are on top
## this is a bit hacky but you can split the data frame and then remerge, since the command commented out will still put E above other values - this command was just order by the col hex
df_plot_1 <- df_plot[!(df_plot$hex == "#e7e7e7"), ]
df_plot_2 <- df_plot[(df_plot$hex == "#e7e7e7"), ]
df_plot <- rbind(df_plot_2, df_plot_1)
rm(df_plot_2, df_plot_1)

umap_zoom_plot_rt <- ggplot(df_plot, aes(x = UMAP_1, y = UMAP_2, colour = hex)) +
                         geom_point(size = 2) +
                        ## need this to tell ggplot2 to map to values
                         scale_colour_identity(guide = "legend") +
                        ## fix coordinates
                         coord_fixed()
  
# Extract the legend. Returns a gtable
leg <- get_legend(umap_zoom_plot_rt)

# Convert to a ggplot and print
legend_d <- as_ggplot(leg)

legend_d
  
umap_zoom_plot_rt+theme(legend.position = "none") +
                         theme_void()

## remove big dataset
#rm(tenx.justwt.integrated)
```

```{r}
## extract metadata
df_plot <- tenx.justwt.integrated@meta.data

## add umap - merge on row names and then make sure row names are not dropped or added
df_plot <- transform(merge(df_plot, tenx.justwt.integrated@reductions[["umap"]]@cell.embeddings, by=0, all=TRUE), row.names=Row.names, Row.names=NULL)

## make new col for colours - and make everything grey
df_plot$hex <- "#e7e7e7"

## extract colours for highlighted cells 
df_plot_2 <- as.data.frame(monocle.object@colData[,"monocle_sex", drop = FALSE])

## then merge this back into the colour column, whilst matching the rows
rownames_to_match <- rownames(df_plot[rownames(df_plot) %in% rownames(df_plot_2), ])

df_plot$hex[rownames(df_plot) %in% rownames(df_plot_2)] <- df_plot_2[match(rownames_to_match, rownames(df_plot_2)), , drop = FALSE][ ,1]

## add actual colours for sexes
# 1 = blue - "#0052c5"
# 2 = red - "#a52b1e"
# 3 = green - "#016c00"
# 4 = yellow - "#ffe400"
#pal_sex <- c("#0052c5","#ffe400", "#a52b1e", "#016c00")
df_plot$hex[df_plot$hex == "Male"] <- "#016c00"
df_plot$hex[df_plot$hex == "Female"] <- "#a52b1e"
df_plot$hex[df_plot$hex == "Bipotential"] <- "#ffe400"
df_plot$hex[df_plot$hex == "Asexual_Early"] <- "#0052c5"

### make character so ggplto2 recognises them
df_plot$hex <- as.character(df_plot$hex)

## reorder so that the voloured points are on top
## this is a bit hacky but you can split the data frame and then remerge, since the command commented out will still put E above other values - this command was just order by the col hex
df_plot_1 <- df_plot[!(df_plot$hex == "#e7e7e7"), ]
df_plot_2 <- df_plot[(df_plot$hex == "#e7e7e7"), ]
df_plot <- rbind(df_plot_2, df_plot_1)
rm(df_plot_2, df_plot_1)

umap_zoom_plot_rt <- ggplot(df_plot, aes(x = UMAP_1, y = UMAP_2, colour = hex)) +
                         geom_point(size = 2) +
                        ## need this to tell ggplot2 to map to values
                         scale_colour_identity(guide = "legend") +
  ## make points bigger
                         guides(colour = guide_legend(override.aes = list(size = 5))) +
                        ## fix coordinates
                         coord_fixed()
  
# Extract the legend. Returns a gtable
#leg <- get_legend(umap_zoom_plot_rt)

# Convert to a ggplot and print
#legend_d <- as_ggplot(leg)

#legend_d
  
umap_zoom_plot_rt <- umap_zoom_plot_rt + theme(legend.position = "none")+  theme_void()

umap_zoom_plot_rt

## remove big dataset
#rm(tenx.justwt.integrated)
```
save
```{r}
ggsave("../images_to_export/UMAP_sex_id.png", plot = umap_zoom_plot_rt, device = "png", path = NULL, scale = 1, width = 21, height = 29.7, units = "cm", dpi = 300, limitsize = TRUE)
```

```{r}
# 1 = blue - "#0052c5"
# 2 = red - "#a52b1e"
# 3 = green - "#016c00"
# 4 = yellow - "#ffe400"
#pal_sex <- c("#0052c5","#ffe400", "#a52b1e", "#016c00")

## extract pseudotime numbers and identity of cells to a dataframe
df_pt_id <- as.data.frame(monocle.object@colData[,c("pt_sex", "monocle_sex")])

## inspect possible values
list_of_sexes <- names(table(df_pt_id$monocle_sex))

## make a new column
df_pt_id$colour <- NA

## make colour ramps
asex_ramp <- colorRampPalette(c("#D5E3F5", "#0052c5"))
male_ramp <- colorRampPalette(c("#ABDDBF", "#016c00"))
female_ramp <- colorRampPalette(c("#F4C1BE", "#a52b1e"))
bipot_ramp <- colorRampPalette(c("white", "#ffe400"))

## re-classify the cells that are unassigned cells removed from sexual branch above:
#df_pt_id[which(rownames(df_pt_id) %in% remove_cells), ]$monocle_sex <- "Asexual"

## assign values to each cluster
## help here: https://stackoverflow.com/questions/9946630/colour-points-in-a-plot-differently-depending-on-a-vector-of-values 
df_pt_id[df_pt_id$monocle_sex == "Asexual_Early" | df_pt_id$monocle_sex == "Asexual_Late", ]$colour <- asex_ramp(100)[as.numeric(cut(df_pt_id[df_pt_id$monocle_sex == "Asexual_Early" | df_pt_id$monocle_sex == "Asexual_Late", ]$pt_sex,breaks = 100))]

df_pt_id[df_pt_id$monocle_sex == "Male", ]$colour <- male_ramp(100)[as.numeric(cut(df_pt_id[df_pt_id$monocle_sex == "Male", ]$pt_sex,breaks = 100))]

df_pt_id[df_pt_id$monocle_sex == "Female", ]$colour <- female_ramp(100)[as.numeric(cut(df_pt_id[df_pt_id$monocle_sex == "Female", ]$pt_sex,breaks = 100))]

df_pt_id[df_pt_id$monocle_sex == "Bipotential", ]$colour <- bipot_ramp(100)[as.numeric(cut(df_pt_id[df_pt_id$monocle_sex == "Bipotential", ]$pt_sex,breaks = 100))]

## ADD TO BIG OBJECT

## extract metadata
df_plot <- tenx.justwt.integrated@meta.data

## add umap - merge on row names and then make sure row names are not dropped or added
df_plot <- transform(merge(df_plot, tenx.justwt.integrated@reductions[["umap"]]@cell.embeddings, by=0, all=TRUE), row.names=Row.names, Row.names=NULL)

## make new col for colours - and make everything grey
df_plot$hex <- "#e7e7e7"

## extract colours for highlighted cells 
df_plot_2 <- as.data.frame(df_pt_id[,"colour", drop = FALSE])

## then merge this back into the colour column, whilst matching the rows
rownames_to_match <- rownames(df_plot[rownames(df_plot) %in% rownames(df_plot_2), ])

df_plot$hex[rownames(df_plot) %in% rownames(df_plot_2)] <- df_plot_2[match(rownames_to_match, rownames(df_plot_2)), , drop = FALSE][ ,1]

### make character so ggplto2 recognises them
df_plot$hex <- as.character(df_plot$hex)

## reorder so that the voloured points are on top
## this is a bit hacky but you can split the data frame and then remerge, since the command commented out will still put E above other values - this command was just order by the col hex
df_plot_1 <- df_plot[!(df_plot$hex == "#e7e7e7"), ]
df_plot_2 <- df_plot[(df_plot$hex == "#e7e7e7"), ]
df_plot <- rbind(df_plot_2, df_plot_1)
rm(df_plot_2, df_plot_1)

## make ggplot
umap_id_pt <- ggplot(df_plot, aes(x = UMAP_1, y = UMAP_2)) + 
                     geom_point(col = df_plot$hex) +
                     theme_void() +
                     coord_fixed()

umap_id_pt
```

save
```{r}
ggsave("../images_to_export/UMAP_sex_id_pt.png", plot = umap_id_pt, device = "png", path = NULL, scale = 1, width = 21, height = 29.7, units = "cm", dpi = 300, limitsize = TRUE)
```

save modules
```{r}
## modules are located in this object:
# gene_module_df_sex
write.csv(gene_module_df_sex, file = "../data_to_export/gene_module_df_sex.csv")
```


# Appendix {.tabset}

## Session Info 
```{r, echo = FALSE}
sessionInfo()
```

### Scaling values in the aggregated heatmap
```{r}
getAnywhere(aggregate_gene_expression)
```

```{r}
## This does the above aggregation function but manually to understand it better.
## This is how we execute the function above.
#agg_mat_no_group <- aggregate_gene_expression(monocle.object, gene_module_df_sex, scale_agg_values = TRUE)

## define variables
# cds = monocle.object
# gene_group_df = gene_module_df_sex
# max_agg_value = 3
# min_agg_value = -3

## perform aggregation
# agg_mat <- normalized_counts(cds)
# gene_group_df <- as.data.frame(gene_group_df)
# gene_group_df <- gene_group_df[gene_group_df[, 1] %in% fData(cds)$gene_short_name | gene_group_df[, 1] %in% row.names(fData(cds)), , drop = FALSE]
# short_name_mask <- gene_group_df[[1]] %in% fData(cds)$gene_short_name
# if (any(short_name_mask)) {
#             geneids <- as.character(gene_group_df[[1]])
#             geneids[short_name_mask] <- row.names(fData(cds))[match(geneids[short_name_mask], 
#                 fData(cds)$gene_short_name)]
#             gene_group_df[[1]] <- geneids
# }
# 
# agg_mat = as.matrix(monocle3:::my.aggregate.Matrix(agg_mat[gene_group_df[,1], ], as.factor(gene_group_df[, 2]), fun = "sum"))

## This scales aggregate values         
#         if (scale_agg_values) {
#             agg_mat <- t(scale(t(agg_mat)))
#             agg_mat[agg_mat < min_agg_value] <- min_agg_value
#             agg_mat[agg_mat > max_agg_value] <- max_agg_value
#         }

```

```{r}
## get an idea of the spread of z-score values 
# test <- (agg_mat_no_group)
# rowRanges(test)
# rowMeans(test)
# test <- t(agg_mat_no_group)
# names(test) = make.names(test)
# test = melt(test)
# ggplot(test, aes(x = Var2, y = value, group = Var2)) + geom_violin()
# rm(test)
```

In conclusion, the plots will look different if scaling is done by heatmap as it does not do the relimiting - i.e. anything < -3 and 3 < for the z-scores. the scaling is done on the transformed columns (e.g. when applying 'scale' to a matrix, it does it in a column-wise manner) which in this case, the modules are columns and so it does the correct scaling required. This is because the input is normalised cell counts and so the cells have already been scaled. 
